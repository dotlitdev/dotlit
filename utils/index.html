<html data-reactroot=""><head><title>.lit Utils</title><meta name="litsrc" value="/utils/index.lit"/><meta name="litroot" value="/"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/><link rel="stylesheet" href="/style.css"/></head><body><div id="lit-app"><div id="lit-header"><menu class="horizontal open has-children"><li class="MenuTitle"><a href="/">Home</a></li><li class="MenuItems"><menu class="has-children"><li class="MenuTitle">File</li></menu><menu class="has-children" disabled=""><li class="MenuTitle">Cell</li></menu><menu class="has-children" disabled=""><li class="MenuTitle">Section</li></menu><menu class="has-children"><li class="MenuTitle">Help</li></menu><menu class="has-children right"><li class="MenuTitle"><span class="led led-grey"></span></li></menu></li></menu><div class="lit-messages"></div></div><style>body {
  --bg: white;
  --bg-secondary-color: #efefef;
    
  --text-color: black;
  --text-secondary-color: grey;
  --text-primary-color: #9999f7;
  --text-highlight-bg: yellow;
  --text-highlight-color: black;

  --divider-subtle: #efefef;
  --medium-space: 0.4em;

  --code-bg-color: black;
  --code-text-color: white;
  --box-bg-opacity: 0.05;
}</style><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.0.0/build/styles/sunburst.min.css"/><div id="content"><section depth="1" class="" startpos="1:1-0" endpos="22:4-502"><cell startpos="1:1-0" endpos="3:100-115"><div class="cell-content"><h1 id="lit-utils"><code>.lit</code> Utils</h1><p>Generally available as <code>lit.utils</code> With some exceptions, inludes <code>lit.utils.React</code> for convenience.</p></div></cell><cell startpos="5:1-117" endpos="6:4-153" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; ./functions.js</span></span><pre><code class="js">export const NoOp = () =&gt; {}
export const Identity = x =&gt; x
export const AsInt = x =&gt; parseInt(x)
export const Undef = x =&gt; typeof x === &#x27;undefined&#x27;

export const getMeta = (key,def) =&gt; {
    if (typeof document === &quot;undefined&quot; || !document.querySelector) return def;

    const el = document.querySelector(`meta[name=&quot;lit${key}&quot;]`)
    const val = el ? el.getAttribute(&#x27;value&#x27;) : def
    return val
}

export const posstr = pos =&gt; {
    return pos ? `${pos.line}:${pos.column}-${pos.offset}` : undefined
}

export const wait = async (ms) =&gt; {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, ms);
    });
}

export const template = (templateString, templateVars) =&gt; {
    console.log(templateString)
    const escaped = templateString.replace(/`/g, &#x27;\\`&#x27;)
    console.log(escaped)
    const body = &quot;return `&quot;+ escaped +&quot;`;&quot;
    console.log(body)
    return new Function(body).call(templateVars)
}
</code></pre></codecell></div></cell><cell startpos="7:1-154" endpos="8:4-188" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; ./console.js</span></span><pre><code class="js">import { NoOp } from &#x27;./functions&#x27;

const ROOT_NS = &#x27;.lit&#x27;
const ROOT_PREFIX = `${ROOT_NS}`

const debugKeys = (...args) =&gt; {
  let debugStr = &#x27;&#x27;
  if (typeof process !== &#x27;undefined&#x27; &amp;&amp; process.env &amp;&amp; process.env.DEBUG) {
    debugStr = process.env.DEBUG
  }

  if (typeof window !== &#x27;undefined&#x27; &amp;&amp; window.location) {
      const debugKeys = localStorage.getItem(&#x27;litDebug&#x27;) || &#x27;&#x27;
      if (debugKeys) debugStr = debugKeys
  }

  return debugStr.split(&#x27;,&#x27;)
}

// console.log(&quot;[console] log mask:&quot;, debugKeys().join(&#x27;,&#x27;) )

const shouldLog = ns =&gt; {
  const keys = debugKeys()
  if (keys.indexOf(`-${ns}`) &gt;= 0) return false;
  return keys.indexOf(&#x27;*&#x27;) &gt;= 0 || keys.indexOf(&#x27;All&#x27;) &gt;= 0 || keys.indexOf(ns) &gt;= 0
}

const level = function(level, fn) {
  const lvlIndent = Array(level).fill(&#x27;  &#x27;).join(&#x27;&#x27;)
  return function(...args) {
    if (level &lt;= debug_level() || shouldLog(level)) fn(`[lit]{${level}}${lvlIndent}`, ...args)
  }
}

const prefixArgs = (prefix, fn, self) =&gt; {
  return (...args) =&gt; {
    const newArgs = [prefix, ...args]
    fn.apply( self, newArgs)
  }
}

const getConsole = (ns) =&gt; {
  const prefix = `[${ROOT_PREFIX}:${ns}] `
  return {
    level: level,
    log: prefixArgs(prefix, console.log, console),
    dir: prefixArgs(prefix, console.dir, console),
    info: prefixArgs(prefix, console.info, console),
    error: prefixArgs(prefix, console.error, console),
    time: console.time,
    timeEnd: console.timeEnd,
    getConsoleForNamespace,
  }
}

export const Console = getConsole(ROOT_NS);
export function getConsoleForNamespace(ns) {
  if (shouldLog(ns)) {
    return getConsole(ns)
  } else {
    if (debugKeys()[0] !== &#x27;None&#x27;) console.log(`[${ROOT_PREFIX}] Hiding console for NS &quot;${ns}&quot;`)
    const prefix = `[${ROOT_PREFIX}:${ns}] `
    return {
      level: NoOp,
      log: NoOp,
      dir: NoOp,
      info: NoOp,
      error: prefixArgs(prefix, console.error, console),
      time: NoOp,
      timeEnd: NoOp,
    }
  }
}





</code></pre></codecell></div></cell><cell startpos="9:1-189" endpos="10:4-222" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; ./colors.js</span></span><pre><code class="js">function hashCode(str) {
    var hash = 0;
    for (var i = 0; i &lt; str.length; i++) {
        hash = str.charCodeAt(i) + ((hash &lt;&lt; 5) - hash);
    }
    return hash;
}

// Convert an int to hexadecimal with a max length
// of six characters.
function intToARGB(i) {
    var hex = ((i&gt;&gt;24)&amp;0xFF).toString(16) +
            ((i&gt;&gt;16)&amp;0xFF).toString(16) +
            ((i&gt;&gt;8)&amp;0xFF).toString(16) +
            (i&amp;0xFF).toString(16);
    // Sometimes the string returned will be too short so we 
    // add zeros to pad it out, which later get removed if
    // the length is greater than six.
    hex += &#x27;000000&#x27;;
    return &#x27;#&#x27; + hex.substring(0, 6);
}

export function pickTextColorBasedOnBgColor(bgColor, lightColor, darkColor) {
    var color = (bgColor.charAt(0) === &#x27;#&#x27;) ? bgColor.substring(1, 7) : bgColor;
    var r = parseInt(color.substring(0, 2), 16); // hexToR
    var g = parseInt(color.substring(2, 4), 16); // hexToG
    var b = parseInt(color.substring(4, 6), 16); // hexToB
    var uicolors = [r / 255, g / 255, b / 255];
    var c = uicolors.map((col) =&gt; {
      if (col &lt;= 0.03928) {
        return col / 12.92;
      }
      return Math.pow((col + 0.055) / 1.055, 2.4);
    });
    var L = (0.2126 * c[0]) + (0.7152 * c[1]) + (0.0722 * c[2]);
    return (L &gt; 0.179) ? darkColor : lightColor;
}
export function stringToHex (str) {
    return intToARGB(hashCode(str))
}

</code></pre></codecell></div></cell><cell startpos="11:1-223" endpos="12:4-263" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; ./safe-encoders.js</span></span><pre><code class="js">var newlineRegex = /\n/g;


export const btoa = (str) =&gt; {
  if (typeof window === &#x27;undefined&#x27; || !window.btoa)  {
    // const Buffer = require(&#x27;buffer&#x27;)
    return Buffer.from(str, &#x27;binary&#x27;).toString(&#x27;base64&#x27;)
  } else return window.btoa(str)
}

export const atob = (str) =&gt; {
  if (typeof window === &#x27;undefined&#x27; || !window.atob)  {
    // const Buffer = require(&#x27;buffer&#x27;)
    return Buffer.from(str, &#x27;base64&#x27;).toString(&#x27;binary&#x27;)
  }
  else return window.atob(str)
}

export function b64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
    return String.fromCharCode(&#x27;0x&#x27; + p1);
  }));
}

export function b64DecodeUnicode(str) {
  // atob on Mobile Safari for iOS 9 will throw an exception if there&#x27;s a newline.
  var b64Decoded = atob(str.replace(newlineRegex, &#x27;&#x27;));
  var decodedWithUnicodeHexesRestored = Array.prototype.map.call(
    b64Decoded,
    hexEncodeCharCode
  )
  .join(&#x27;&#x27;);

  return decodeURIComponent(decodedWithUnicodeHexesRestored);
}

function hexEncodeCharCode(c) {
  return &#x27;%&#x27; + (&#x27;00&#x27; + c.charCodeAt(0).toString(16)).slice(-2);
}

</code></pre></codecell></div></cell><section depth="2" class="" startpos="14:1-265" endpos="22:4-502"><cell startpos="14:1-265" endpos="16:119-399"><div class="cell-content"><h2 id="unist-utils">Unist utils</h2><p>Various <code>unist-util-*</code> utilities used by <code>.lit</code> and some custom built, exposed for convenience under <code>lit.utils.unist</code></p></div></cell><cell startpos="18:1-401" endpos="19:4-449" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; unist-util-patch-source.js</span></span><pre><code class="js">
const patchSource = (src, originalLocation, value) =&gt; {
    const pos = originalLocation.position || originalLocation
    if (!pos) throw Error(&quot;No location to patch&quot;)
    return src.slice(0, pos.start.offset) + value + src.slice(pos.end.offset);
}

export default patchSource

</code></pre></codecell></div></cell><cell startpos="21:1-451" endpos="22:4-502" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; unist-util-select-position.js</span></span><pre><code class="js">import filter from &#x27;unist-util-filter&#x27;
import {selectAll as select} from &#x27;unist-util-select&#x27;
import { getConsoleForNamespace } from &#x27;./console&#x27;

const console = getConsoleForNamespace(&#x27;util&#x27;)

export const atPos = pos =&gt; (node) =&gt; {
  const pos2 = node.position
  if (!pos2 || !pos2.start || !pos2.end) {
    console.error(&quot;no pos&quot;, node)
    return false
  }

  const startInside = (pos2.start.line &gt;= pos.start.line
    &amp;&amp; pos2.start.line &lt;= pos.end.line)

  const endInside = (pos2.end.line &gt;= pos.start.line
    &amp;&amp; pos2.end.line &lt;= pos.end.line)

  const wraps = pos2.start.line &lt;= pos.start.line 
    &amp;&amp; pos2.end.line &gt;= pos.end.line

  const any = wraps || startInside || endInside 
  // console.log(&quot;atPos: &quot; + node.type, any ,pos2.start.line, pos2.end.line, wraps, startInside, endInside, pos.start.line, pos.end.line)
  return any
}

export const selectAll = (type, pos, tree) =&gt; {
  const filteredTree = filter(tree, atPos(pos))
  const nodes = select(type, filteredTree)
  return nodes
}

</code></pre></codecell></div></cell></section></section>
<section depth="2" class="" startpos="24:1-504" endpos="36:115-919"><cell startpos="24:1-504" endpos="26:136-660"><div class="cell-content"><h2 id="filesystem-utils">Filesystem utils</h2><p>The raw [lightning-fs] object is available as <code>lit.lfs</code> while the extended and customised wrapper used throughout <code>.lit</code> is at <code>lit.fs</code></p></div></cell><cell startpos="28:1-662" endpos="29:4-704" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; fs-promises-utils.js</span></span><pre><code class="js">import path from &quot;path&quot;;
import { ghWriteFile, ghReadFile, ghDeleteFile } from &quot;../utils/fs-promises-gh-utils&quot;;
import { getConsoleForNamespace } from &#x27;./console&#x27;

const console = getConsoleForNamespace(&#x27;fs&#x27;)

const passThroughRead = (origReadFile, litroot) =&gt; {
  
  return async (...args) =&gt; {
    console.log(&#x27;fs.passThroughRead&#x27;, args[0])
    try {
      return await origReadFile(...args);
    } catch (err) {
      if (args[1] &amp;&amp; args[1].localOnly) throw err;
      const filePath = path.join(litroot, args[0])
      console.log(&#x27;fs.passThroughRead passing through to fetch&#x27;, filePath)
      const resp = await fetch(filePath)
      if (resp.status === 404) throw new Error(`404 File ${filePath} not found.`)
      return await resp.text();
    }
  };
}

const passThroughReadWithStat = (origReadFile, origStat, litroot, ghOpts, noPassthrough) =&gt; {

  return async (...args) =&gt; {
    console.log(&#x27;fs.passThroughReadWithStat&#x27;, litroot, args[0])

    const resp = {
      local: { stat: undefined, value: undefined },
      remote: { stat: undefined, value: undefined },
    }
    const filePath = args[0] = path.join(litroot, args[0])
    try {
      try {
        resp.local.stat = await origStat(...args)
      } catch(err){
        console.log(&quot;fs.passThoughReadWithStat no stat on local file&quot;)
      }
      const value = await origReadFile(...args)
      resp.local.value = value
    } catch (err) { 
      console.log(&#x27;fs.passThoughReadWithStat no local file&#x27;, err)
    }

    

    let remoteResp
    if (ghOpts) {
        console.log(&quot;fs.passThroughtReadWithStat passing through to GitHub&quot;, filePath)
        const ghrf = ghReadFile(ghOpts)
        try {
             remoteResp = await ghrf(filePath)
        } catch(err){
             console.log(&quot;fs.passThroughtReadWithStat GitHub read failed&quot;, err) 
        }
    } else if (noPassthrough) {
      return resp
    } else {
        console.log(&#x27;fs.passThroughReadWithStat passing through to fetch&#x27;, filePath)
        remoteResp = await fetch(filePath)
    }

    if (!remoteResp || remoteResp.status &lt; 200 || remoteResp.status &gt;= 400) {
      if (!resp.local.stat &amp;&amp; !resp.local.value) {
        console.log(&#x27;fs.passThroughReadWithStat failed local and remote read&#x27;)
        throw new Error(`${remoteResp?.status || &quot;Request&quot;} Error. Fetching File.`)
      }
    } else {
      console.log(&quot;fs.passThroughReadWithStat found remote file&quot;)
      const value = await remoteResp.text()
      const lastModified = remoteResp.headers &amp;&amp; remoteResp.headers.get(&#x27;last-modified&#x27;)
      const contentLength = remoteResp.headers &amp;&amp; remoteResp.headers.get(&#x27;content-length&#x27;)
      const stat = {
        dev: 1,
        gid: 1,
        ino: 1,
        uid: 1,
        mtimeMs: lastModified &amp;&amp; (new Date(lastModified)).getTime(),
        size: contentLength,
      }
      resp.remote = {stat,value}
    }

    return resp
  };
}

const writeFileP = (fs, litroot) =&gt; {
  const wf = fs.writeFile
  return async (...args) =&gt; {
    console.log(&quot;fs.writeFileP &quot;, args[0])
    const filepath = (args[0] = litroot + args[0]);
    const p = path.parse(filepath);
    const parts = p.dir.split(path.sep);
    // console.log(`&quot;Parts for &quot;${filepath}&quot;`, parts);
    for (var i = 0; i &lt; parts.length; i++) {
      // console.log(`[${i}] &lt;--- &quot;${parts[i]}&quot;`);
      if (i === 0) {
      } else {
        const subPath = parts.slice(0, i + 1).join(path.sep);
        // console.log(`&quot;${subPath}&quot; Sub path`);
        try {
          await fs.mkdir(subPath);
        } catch (err) {
          // console.log(`[fs.writeFileP] &quot;${subPath}&quot; Failed to mkdirpath `);
        }
      }
    }
    // console.log(&quot;[fs.writeFileP] Writing file&quot;, ...args);
    return wf(...args);
  };
}

const passThroughWrite = (fs,litroot, ghOpts) =&gt; {
  const wf = fs.writeFile
  return async (...args) =&gt; {
    console.log(&#x27;fs.passThroughWrite&#x27;)
    await wf(...args);
    if (ghOpts &amp;&amp; !(args[2] &amp;&amp; args[2].localOnly)) {
      const ghwf = ghWriteFile(ghOpts);
      try {
        const ghResp = await ghwf(...args);
        console.log(&quot;GitHub write resp&quot;, ghResp);
      } catch (err) {
        console.error(&quot;GitHub write threw&quot;, err);
      }
    }
  };
}

const passThroughUnlink = (fs,litroot, ghOpts) =&gt; {
  const uf = fs.unlink
  return async (filepath, localOnly) =&gt; {
    console.log(&#x27;fs.passThroughUnlink&#x27;)
    let local
    try {
        local = await uf(filepath, localOnly)
    } catch (err) {
        console.log(&quot;fs.passThroughUnlink didn&#x27;t unlink local file&quot;, err)
    }
    if (localOnly) return local;
    if (ghOpts) {
      const ghdf = ghDeleteFile(ghOpts);
      let ghResp
      try {
        ghResp = await ghdf(filepath.slice(1));
        console.log(&quot;GitHub delete resp&quot;, ghResp);
      } catch (err) {
        console.error(&quot;GitHub delete threw&quot;, err.message, err);
      }
      return ghResp
    } else {
      return local
    }
  };
}

export const extendFs = (fs, litroot = &quot;&quot;, ghOpts, noPassthrough) =&gt; {
  const clonedfs = {...fs}
  const origReadFile = clonedfs.readFile
  const origStat = clonedfs.stat
  
  
  if (!noPassthrough) clonedfs.readFile = passThroughRead(origReadFile,litroot);
  clonedfs.writeFile = writeFileP(clonedfs, litroot);
  clonedfs.readStat = passThroughReadWithStat(clonedfs.readFile, origStat, litroot, ghOpts, noPassthrough)

  if(ghOpts) clonedfs.writeFile = passThroughWrite(clonedfs, litroot, ghOpts);
  if(ghOpts) clonedfs.unlink = passThroughUnlink(clonedfs, litroot, ghOpts);

  return clonedfs
};

</code></pre></codecell></div></cell><cell startpos="31:1-706" endpos="32:4-751" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; fs-promises-gh-utils.js</span></span><pre><code class="js">import { b64EncodeUnicode, b64DecodeUnicode } from &#x27;./safe-encoders&#x27;
import { getConsoleForNamespace } from &#x27;./console&#x27;
import {join} from &#x27;path&#x27;

const console = getConsoleForNamespace(&#x27;fs/gh&#x27;)

const getEndpoint = (opts,file) =&gt; `https://api.github.com/repos/${opts.username}/${opts.repository}/${join(&#x27;contents&#x27;, file)}`

export const ghReadFile = opts =&gt; async (...args) =&gt; {
    const file = join(opts.prefix,args[0])
    const params = {
        method: &quot;GET&quot;,
        headers: {
            &quot;Authorization&quot;: `token ${opts.token}`,
            &#x27;Content-Type&#x27;: &#x27;application/json&#x27;
        },
    }
    const resp = await fetch(getEndpoint(opts,file), params)
    // resp.origJson = resp.json
    resp.text = async () =&gt; {
        console.log(&quot;ghReadFile text()...&quot;)
        const data = await resp.json()
        console.log(&quot;ghReadFile data&quot;, data)
        const content = b64DecodeUnicode(data.content)
        console.log(&quot;ghReadFile decoded&quot;)
        return content
    }
    console.log(&quot;ghReadFile&quot;, file, resp)
    return resp
}

export const ghWriteFile = (opts) =&gt; async (...args) =&gt; {
    const file = join(opts.prefix,args[0])
    const content = args[1].toString()
    console.log(&quot;ghWriteFile&quot;, file)
    const endpoint = getEndpoint(opts, file)
    const resp1 = await fetch(endpoint, {
        method: &quot;GET&quot;,
        headers: {
            &quot;Authorization&quot;: `token ${opts.token}`,
            &#x27;Content-Type&#x27;: &#x27;application/json&#x27;
        }
    })
    const json1 = await resp1.json()
    console.log(endpoint, json1.sha ? &quot;Exists, updating...&quot;:&quot;Dosn&#x27;t exist, creating...&quot;)
    const params = {
        method: &quot;PUT&quot;,
        headers: {
            &quot;Authorization&quot;: `token ${opts.token}`,
            &#x27;Content-Type&#x27;: &#x27;application/json&#x27;
        },
        body: JSON.stringify({
            sha: json1.sha,
            message: opts.commitMessage || `Edited ${file}`,
            content: b64EncodeUnicode(content)
        })
    }
    console.log(&quot;ghWriteFile params&quot;, params)
    let resp2;
    try {
      resp2 = await fetch(endpoint, params)
    } catch(err) {
      console.log(&quot;ghWriteFile PUT failed&quot;, err)
    }
    return resp2 &amp;&amp; resp2.status
}

export const ghDeleteFile = opts =&gt; async (...args) =&gt; {
    const file = join(opts.prefix,args[0])
    console.log(&quot;ghDeleteFile&quot;, file)
    const endpoint = getEndpoint(opts, file)
    const resp1 = await fetch(endpoint)
    const json1 = await resp1.json()
    console.log(endpoint, json1.sha ? &quot;Exists, deleting...&quot;:&quot;Dosn&#x27;t exist&quot;)
    const params = {
        method: &quot;DELETE&quot;,
        headers: {
            &quot;Authorization&quot;: `token ${opts.token}`,
            &#x27;Content-Type&#x27;: &#x27;application/json&#x27;
        },
        body: JSON.stringify({
            sha: json1.sha,
            message: opts.commitMessage || `Deleted ${file}`,
        })
    }
    console.log(&quot;ghDeleteFile params&quot;, params)
    let resp2;
    try {
      resp2 = await fetch(endpoint, params)
      const json = await resp2.json()
      console.log(&quot;ghDeleteFile DELETE response&quot;, resp2, json)
    } catch(err) {
      console.log(&quot;ghDeleteFile DELETE failed&quot;, err.message, err)
    }
    return resp2 &amp;&amp; resp2.status
}

</code></pre></codecell></div></cell><cell startpos="33:1-752" endpos="34:4-803" class="code"><div class="cell-content"><codecell class="dir-collapse tag-notyetused lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span style="color:white;background-color:#781c72" class="tag">notyetused</span><span class="source">&lt; git-commit-all.js</span></span><pre><code class="js">
// initially, because it&#x27;s on every change 
// a commit will mostly be for a single
// file at a time the immediate exception 
// being when a file with output files 
// is edited, in which case the commit 
// includes those files.

export const onSave = async (filename) =&gt; {
  const now = (new Date()).toISOString()

  const fs = lit.lfs 
  const dir = lit.location.root
  const git = lit.git
  const FILE = 0, WORKDIR = 2, STAGE = 3

  const unstaged = row =&gt; {
    return row[WORKDIR] !== row[STAGE]
  }

  // get/list unstaged files
  const status = await git.statusMatrix({ fs,dir})
  const files = status
                .filter( unstaged )
                .map(row =&gt; row[FILE])

  // stage everything
  await git.add({fs, dir, filepath: &#x27;.&#x27;})

  // message 
  const message = `Auto commit ${filename}

at ${now} includes the following ${files.length} files:
${files.map(f=&gt; &quot;- &quot; + f).join(&#x27;\n&#x27;)}`

  // commit
  const sha = await git.commit({fs, dir,
    message,
    author: {
      name: &#x27;dotlit&#x27;,
      email: &#x27;bit@dotlit.org&#x27;
    }
  })
  return `Committed ${sha.slice(0,6)} 
${message}`
}

// return onSave(lit.location.src)

</code></pre></codecell></div></cell><cell startpos="36:1-805" endpos="36:115-919"><div class="cell-content"><p>Some additional utils include <code>lit.delete()</code> and <code>lit.read()</code> these were used during testing but will likely move.</p></div></cell></section>
<section depth="2" class="" startpos="38:1-921" endpos="40:91-1024"><cell startpos="38:1-921" endpos="40:91-1024"><div class="cell-content"><h2 id="momento">Momento</h2><p>A basic [moment.js] alternative, for displaying user friendly times. See <a class="exists local" href="momento.html" title="utils/momento" wikilink="true" filepath="/utils/index.lit" root="" data="[object Object]" canonical="/utils/momento.lit">utils/momento</a></p></div></cell></section>
<section depth="2" class="" startpos="42:1-1026" endpos="46:4-1062"><cell startpos="42:1-1026" endpos="42:9-1034"><div class="cell-content"><h2 id="other">Other</h2></div></cell><cell startpos="44:1-1036" endpos="46:4-1062" class="code"><div class="cell-content"><codecell class="lang-js local"><span class="meta"><span class="lang">js</span></span><pre><code class="js">return lit.utils
</code></pre></codecell></div></cell></section></div></div><div id="backlinks"><h4>Backlinks (1)</h4><ol><li><a title=".lit" href="/index.html">.lit</a></li></ol></div><script src="//cdn.jsdelivr.net/npm/eruda"></script><script>eruda.init();</script><script async="" src="/web.bundle.js"></script></body></html>