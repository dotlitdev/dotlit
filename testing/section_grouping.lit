# [[ðŸ”¬ Testing]] Section grouping

Pseodo code steps, operating during `parse` of standard `mdast`.

- With a stack initialised with root node (with children removed) ie `[root]`
- Iterate over all removed root chilren (in reverse? TBD) as `node`
  - define `section` as top of stack
  - if `section` is `root`
    - create section with `node` depth or 0.
    - add `node` as child of section
    - push section to top of stack
  - else if `node` is a `heading`
    - with deeper depth?
      - create section with `node` depth
      - add `node` as child of section
      - push section to top of stack
    - else
      - pop the stack until top of stack has depth equal to or lower (shallower) than `node` depth.
      - create section with `node` depth
      - add `node` as child of section
      - push section to top of stack
  - else add `node` to `section`

```>js ../parser/sections-v3.js
// This files source is defined in [[testing/section_grouping|ðŸ”¬ Testing Section grouping]]

export const sections = (...args) => (tree) => {
  const stack = [tree]
  const nodes = tree.children
  tree.children = []

  const createSection = (node) => {
    const section = {
      type: 'section',
      children: [node],
      depth: node.depth || 0,
    }
    // TODO? push section to stack[-1].children
    stack.push(section)
  }

  for (const node in nodes) {
    const section = stack[-1]
    if (section.type === 'root') {
      createSection(node)
    } else if (node.type === 'heading') {
      if (node.depth > section.depth) {
        createSection(node)
      } else {
        // TODO? stop before popping root?
        while (stack[-1].depth > node.depth ) {
          stack.pop()
        }
        createSection(node)
      }
    } else {
      section.children.push(node)
    }
  }

}
```