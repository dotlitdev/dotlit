<html data-reactroot=""><head><title>Parser</title><meta name="litsrc" value="parser/parser.lit"/><meta name="litroot" value="/"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/><link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/railscasts.css"/><link rel="stylesheet" href="/style.css"/></head><body><div id="lit-app"><div id="lit-header"><menu class="horizontal open has-children"><li class="MenuTitle"><a href="/">Home</a></li><li class="MenuItems"><menu class="has-children"><li class="MenuTitle">File</li></menu><menu class="has-children" disabled=""><li class="MenuTitle">Cell</li></menu><menu class="has-children" disabled=""><li class="MenuTitle">Section</li></menu><menu class="has-children"><li class="MenuTitle">Help</li></menu><menu class="has-children right"><li class="MenuTitle"><span class="led led-grey"></span></li></menu></li></menu><div class="lit-messages"></div></div><div id="content"><section depth="1" class="" startpos="1:1-0" endpos="5:21-185"><cell startpos="1:1-0" endpos="3:154-163"><div class="cell-content"><h1 id="parser">Parser</h1><p>Built atop the <a href="unified.html?file=unified.lit" title="unified" wikilink="true">unified</a> ecosystem, specifically <a href="remark.html?file=remark.lit" title="remark" wikilink="true">remark</a>, which takes <code>.lit</code> <a href="markdown.html?file=markdown.lit" title="Markdown" wikilink="true">Markdown</a> source and outputs <code>mdast</code> (Markdown Abstract Syntax Tree)</p></div></cell><section depth="2" class="" startpos="5:1-165" endpos="5:21-185"><cell startpos="5:1-165" endpos="5:21-185"><div class="cell-content"><h2 id="table-of-contents">Table of Contents</h2><ul>
<li>
<p><a href="#implementation-1">Implementation<span class="linkIcon">§</span></a></p>
</li>
<li>
<p><a href="#extensions">Extensions<span class="linkIcon">§</span></a></p>
<ul>
<li><a href="#frontmatter">Frontmatter<span class="linkIcon">§</span></a></li>
<li><a href="#sections">Sections<span class="linkIcon">§</span></a></li>
<li><a href="#cells">Cells<span class="linkIcon">§</span></a></li>
<li><a href="#codeblocks">Codeblocks<span class="linkIcon">§</span></a></li>
<li><a href="#markdown-blocks">Markdown blocks<span class="linkIcon">§</span></a></li>
<li><a href="#links">Links<span class="linkIcon">§</span></a></li>
</ul>
</li>
<li>
<p><a href="#ast-to-string">AST to String<span class="linkIcon">§</span></a></p>
</li>
</ul></div></cell></section></section>
<section depth="2" class="" startpos="13:1-312" endpos="16:4-374"><cell startpos="13:1-312" endpos="13:19-330"><div class="cell-content"><h2 id="implementation-1">Implementation</h2></div></cell><cell startpos="15:1-332" endpos="16:4-374" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; index.js</span></span><pre><code class="js">import unified from &#x27;unified&#x27;
import markdown from &#x27;remark-parse&#x27;
import remarkStringify from &#x27;remark-stringify&#x27;
import slug from &#x27;remark-slug&#x27;
import headingIds from &#x27;remark-heading-id&#x27;
import toc from &#x27;remark-toc&#x27;
import footnotes from &#x27;remark-footnotes&#x27;
import gfm from &#x27;remark-gfm&#x27;
import { wikiLinkPlugin } from &#x27;remark-wiki-link&#x27;
import select from &#x27;unist-util-select&#x27;
import { to_string } from &#x27;./utils/mdast-util-to-string&#x27;
import toMarkdown from &#x27;mdast-util-to-markdown&#x27;

import {sections, groupIntoSections, ungroupSections} from &#x27;./sections&#x27;
import codeblocks from &#x27;./codeblocks&#x27;
import frontmatter from &#x27;./frontmatter&#x27;
import {mdblocks} from &#x27;./mdblocks&#x27;
import {resolveLinks, wikiLinkOptions} from &#x27;./links&#x27;
import { getConsoleForNamespace} from &#x27;../utils/console&#x27;
//import { transform as jsTransform } from &#x27;./transformers/js&#x27;

const jsTransform = null
const console = getConsoleForNamespace(&#x27;parser&#x27;)

const baseProcessor = ({litroot, files} = {}) =&gt; {
    return unified()

    .use((...args) =&gt; (tree, file) =&gt; {
        console.log(&quot;Parsing file&quot;, file.path)
    })

    // remark
    .use(markdown, {})
    .use(gfm)
    .use(frontmatter, {})

    // Extact title
    .use((...args) =&gt; (tree,file) =&gt; {
        if(!file.data.frontmatter || !file.data.frontmatter.title) {
           
           file.data = file.data || {}
           file.data.frontmatter = file.data.frontmatter || {}
           const heading = select.select(&#x27;heading&#x27;, tree)
           // console.log(&quot;Found heading:&quot;, heading)
           if (heading) {
               console.log(&quot;No title in frontmatter, extracting heading.&quot;)
               const title = to_string(heading)
               file.data.frontmatter.title = title
           }
        }
    },{})

    .use(wikiLinkPlugin, wikiLinkOptions(files))
    .use(slug)
    .use(toc, {})
    .use(headingIds)
    .use(footnotes, {inlineNotes: true})
}

export const processor = ({files, fs, litroot} = {files: []}) =&gt; {
    console.log(`Setting up processor litroot: &quot;${litroot}&quot; files: ${!!files} fs: ${!!fs}`)
    return baseProcessor({files, litroot})
    // remark-litmd (rehype compatable)

    .use(codeblocks)
    // Async reparse `md` codeblocks as children
    .use(mdblocks, {baseProcessor})
    .use(resolveLinks({litroot}))

    .use(sections, {})

}

export const utils = {
  mdblocks,
  sections, ungroupSections,
  resolveLinks,
  codeblocks,
  remarkStringify,
  to_string,
  toMarkdown,
  frontmatter,
}

export async function parse(vfile, options) {
    const p = processor(options)
    const parsed = await p.parse( vfile )
    const ast = await p.run(parsed)
    if (!parsed.data) parsed.data = {}
    parsed.data.ast = ast
    // parsed.data.frontmatter = select.selectAll(&#x27;html&#x27;,ast).reduce( (memo,el) =&gt; Object.assign(memo,el.data || {}),{})
    return parsed
}

export const transformers = {
    jsx: jsTransform,
}


export function stringify(vfile) {
    return processor()
        .use(ungroupSections())
        .use(remarkStringify, {
            bullet: &#x27;-&#x27;,
            // handlers: {
            //     cell: debugAstToMarkdown,
            //     section: debugAstToMarkdown
            // }
        })
        .process(vfile)
}

</code></pre></codecell></div></cell></section>
<section depth="2" class="" startpos="18:1-376" endpos="23:4-460"><cell startpos="18:1-376" endpos="18:14-389"><div class="cell-content"><h2 id="extensions">Extensions</h2></div></cell><section depth="3" class="" startpos="19:1-390" endpos="23:4-460"><cell startpos="19:1-390" endpos="20:17-422"><div class="cell-content"><h3 id="frontmatter">Frontmatter</h3><p><em>Implementation</em></p></div></cell><cell startpos="22:1-424" endpos="23:4-460" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; frontmatter.js</span></span><pre><code class="js">import visit from &#x27;unist-util-visit&#x27;
import before from &#x27;unist-util-find-before&#x27;
import after from &#x27;unist-util-find-after&#x27;
import yaml from &#x27;js-yaml&#x27;

import {log, level} from &#x27;../utils/console&#x27;
import { notEqual } from &#x27;assert&#x27;
import { getConsoleForNamespace } from &#x27;../utils/console&#x27;

const console = getConsoleForNamespace(&#x27;frontmatter&#x27;)

const FRONTMATTER_OPEN = &#x27;&lt;!-- data&#x27;
const FRONTMATTER_CLOSE = &#x27;--&gt;&#x27;

export default function (...args) {
    return (tree,file) =&gt; {
        const matters = []
        visit( tree, &#x27;html&#x27;, (node, index, parent) =&gt; {  
            if (node.value.indexOf(FRONTMATTER_OPEN) === 0 &amp;&amp; node.value.indexOf(FRONTMATTER_CLOSE) === (node.value.length - FRONTMATTER_CLOSE.length)) {
                console.log( &#x27;Raw&#x27;, node.value)
                const yamlString = node.value.slice(FRONTMATTER_OPEN.length, node.value.length - FRONTMATTER_CLOSE.length).trim()
                try {
                    node.data = yaml.load(yamlString, &#x27;utf8&#x27;)
                } catch(err) {
                    node.data = {error: err.toString()}
                }
               console.log( &#x27;Parsed&#x27;, yamlString)
               matters.push(node.data)
            }
        })
        file.data.frontmatter = matters.reduce( (memo,matter) =&gt; Object.assign({}, memo, matter || {}), {})
    }
}


</code></pre></codecell></div></cell></section></section>
<section depth="3" class="" startpos="25:1-462" endpos="41:4-735"><cell startpos="25:1-462" endpos="27:74-549"><div class="cell-content"><h3 id="sections">Sections</h3><p>Sections are automatically created from the nested structure of Headings.</p></div></cell><cell startpos="29:1-551" endpos="32:4-614" class="code"><div class="cell-content"><codecell class="lang-md local"><span class="meta"><span class="lang">md</span></span><pre><code class="md"># Headline (root section)
## Subtitle (child section)
</code></pre></codecell></div></cell><cell startpos="34:1-616" endpos="34:34-649"><div class="cell-content"><p>They can be collapse/folded (tbd)</p></div></cell><cell startpos="36:1-651" endpos="38:4-684" class="code"><div class="cell-content"><codecell class="lang-md local"><span class="meta"><span class="lang">md</span></span><pre><code class="md"># &gt;Headline (collapsed)
</code></pre></codecell></div></cell><cell startpos="39:1-685" endpos="39:17-701"><div class="cell-content"><p><em>Implementation</em></p></div></cell><cell startpos="40:1-702" endpos="41:4-735" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; sections.js</span></span><pre><code class="js">import heading from &quot;mdast-util-heading-range&quot;;
import visit from &quot;unist-util-visit&quot;;
import flatMap from &quot;unist-util-flatmap&quot;;
import { getConsoleForNamespace } from &#x27;../utils/console&#x27;
import { Identity } from &quot;../utils/functions&quot;;

const console = getConsoleForNamespace(&#x27;sections&#x27;, {disabled: true})

const firstChild = (node,type) =&gt; node.children 
            &amp;&amp; node.children[0]
            &amp;&amp; node.children[0].type === type

const createCell = (node,nodes) =&gt; {
     const pos = node.position
     // pos.start.offset = pos.start.offset - pos.start.column
     // pos.start.column = 0
     return {
          type: &quot;cell&quot;,
          position: pos,
          data: {
            hName: &quot;cell&quot;,
            hProperties: {
              class: &quot;cell&quot;,
            },
          },
          children: nodes || [node],
        }
}

const createSection = (node,nodes) =&gt; {
  if (!nodes) node.children = cellsFromNodes(node.children)
  return {
        type: &quot;section&quot;,
        data: {
          hName: &quot;section&quot;,
        },
        position: node.position,
        children: nodes || [node],
      }
}

const cellsFromNodes = (nodes, {addSectionDataToFirstCell}={}) =&gt; {

  const cells = [];
  let newCell = null;

  nodes.map((current, index) =&gt; {
    const node = current;
    console.log(&quot;[Sections] child: &quot;, index, node.type);

    if (node.type === &quot;section&quot;) {
      newCell = null;
      cells.push(node);

    } else if (false &amp;&amp; node.type === &quot;list&quot; &amp;&amp; node.spread) {
      newCell = null;
      let listSection = createSection(node)
      cells.push(listSection);

    } else if (false &amp;&amp; node.type === &quot;listItem&quot; &amp;&amp; node.spread) {
      newCell = null;
      let listItem = node
      if (firstChild(listItem, &#x27;section&#x27;)) {
        console.log(&quot;[Sections] ListItem with section: &quot;, node.type);
        listItem.children = listItem.children.map( section =&gt; {
          section.children = cellsFromNodes(section.children)
        })
      } else {
        listItem.children = [createSection(node, node.children)]
      }
      
      cells.push(listItem);

    } else if (node.type === &quot;code&quot;) {
      const next = nodes[index+1]
      const attached = node =&gt; node &amp;&amp; node.data &amp;&amp; node.data.meta &amp;&amp; node.data.meta.attached
      const nextIsAttached = attached(next)
                            
      let singleCell = createCell(node)
      if (nextIsAttached) {
          newCell = singleCell
         
      } else if (newCell &amp;&amp; attached(node)) {
          newCell.children.push(node)
          if (node.position) newCell.position.end = node.position.end;
          cells.push(newCell)
          newCell = null

      } else {
          newCell = null
          cells.push(singleCell);
      }
     
     
      
    } else if (newCell) {
      newCell.children.push(node);
      if (node.position) newCell.position.end = node.position.end;

    } else {
      newCell = createCell(node)
      if(addSectionDataToFirstCell) newCell.data.section = addSectionDataToFirstCell
      cells.push(newCell);
    }
  });
  return cells;

}

const wrapSection = (options) =&gt; (start, nodes, end) =&gt; {
  console.log(
    &quot;[Sections] Wrapping:&quot;,
    start &amp;&amp; start.data.id,
    nodes &amp;&amp; nodes.length,
    end &amp;&amp; end.type
  );

  nodes = [start, ...nodes]

  // log(&quot;[Section] nodes:&quot;, nodes)

  const cells = cellsFromNodes(nodes)

  return [
    {
      type: &quot;section&quot;,
      data: {
        id: start.data.id,
        hName: &quot;section&quot;,
        hProperties: {
          name: start.data.id,
        },
      },
      position: {
        start: start.position.start,
        end: end ? end.position.end : nodes[nodes.length - 1].position.end,
      },
      children: [
        // Mark that heading as having been mutated,
        // otherwise we&#x27;d be processing the same header
        // over and over (infinite loop)
        ...cells,
      ],
    },
  ];
};

const transform = (options) =&gt; (node, index, parent) =&gt; {
  console.log(&quot;[Sections] Visiting&quot;, node.data.id)
  return heading(
    parent,
    (_, node2) =&gt; node.data.id === node2.data.id,
    wrapSection(options)
  )
}

export const groupIntoSections = (options = {}) =&gt; (...args) =&gt; (tree) =&gt; {
  console.log(&quot;[Sections] Init&quot;);
  visit(tree, &quot;heading&quot;, transform(options), true);
}

export const sections = (...args) =&gt; (tree) =&gt; {
  console.log(&#x27;[Sections II] Init.&#x27;, args, tree.type, tree.children.length)
  let headings = 0
  const newSection = (children) =&gt; {
    const first = children[0]
    const last = children[ children.length - 1]
    const depth = first.depth || 0
    first.processed = true
    return {
      type: &#x27;section&#x27;,
      data: {
        name: first.data.id,
        hName: &#x27;section&#x27;,
        hProperties: {
          depth: depth
        }
      },
      depth: depth,
      children: children,
      position: {
        start: first.position.start,
        end: last.position.end
      }
    }
  }

  visit(tree, &#x27;heading&#x27;, (node, index, parent) =&gt; {
    if (node.processed) {
      console.log(`[Sections II] Ignoring already processed node ${node.data.id}`)
    } else if (parent.type === &#x27;root&#x27;) {
      console.log(`[Sections II] heading &quot;${node.data.id}&quot; ${headings}, depth: ${node.depth}`)
      const section = parent.children[index] = newSection([node])
      const children = parent.children
      
      for (let i = index + 1; i &lt; children.length; i++) {
        if (!children[i] || children[i].processed) {
          console.log(&#x27;Skipping removed&#x27;, children[i])
          break
        }
        const nextNode = children[i]
        if ((nextNode.type === &#x27;heading&#x27; || nextNode.type === &#x27;section&#x27;) &amp;&amp; nextNode.depth &lt;= node.depth) {
          console.log(`[Sections II] ended &quot;${node.data.id}&quot; due to &quot;${nextNode.data.id || nextNode.data.name}&quot;`, nextNode.type, nextNode.depth)
          console.log(`[Sections II] contains: &quot;${node.data.id}&quot;`, section.children.map( n =&gt; n.type).join(&#x27;,&#x27;))
          break;
        }
        console.log(`[Sections II] child index: ${i}, type: ${nextNode.type} depth: ${nextNode.depth} id: ${nextNode.data &amp;&amp; (nextNode.data.id || nextNode.data.name)}`)
        section.children.push(nextNode)
        if (nextNode.position) section.position.end = nextNode.position.end
        delete parent.children[i]
      }
      headings++
      node = section 
      node.children = cellsFromNodes(node.children, {addSectionDataToFirstCell: { id: section.data.id, position: section.position}})
    } else {
      console.log(&#x27;[Sections II] WARN: Header parent not root&#x27;, node.data.id)
    }
  }, true)

  tree.children = tree.children.filter(Identity)

  console.log(&quot;Headings: &quot;, headings)
}


const cells = (...args) =&gt; (tree) =&gt; {
  visit( tree, cells )
}


export const ungroupSections = (options = {}) =&gt; (...args) =&gt; (tree) =&gt; {
  console.log(&quot;[UnSection] Init&quot;, options)
  tree = flatMap(tree, (node) =&gt; {
    if (node.type === &quot;cell&quot;) {
      return node.children
    } else if (node.type === &quot;section&quot;) {
      return node.children
    } else {
      return [node]
    }
  })
  return tree
}

</code></pre></codecell></div></cell></section>
<section depth="3" class="" startpos="43:1-737" endpos="45:60-807"><cell startpos="43:1-737" endpos="45:60-807"><div class="cell-content"><h3 id="cells">Cells</h3><p><em>Currently implemented as part of <strong>Sections</strong>, see above.</em></p></div></cell></section>
<section depth="3" class="" startpos="47:1-809" endpos="52:4-878"><cell startpos="47:1-809" endpos="49:17-841"><div class="cell-content"><h3 id="codeblocks">Codeblocks</h3><p><em>Implementation</em></p></div></cell><cell startpos="51:1-843" endpos="52:4-878" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; codeblocks.js</span></span><pre><code class="js">import visit from &#x27;unist-util-visit&#x27;
import { getConsoleForNamespace } from &#x27;../utils/console&#x27;

const console = getConsoleForNamespace(&#x27;codeblocks&#x27;)

const LSP = &#x27;__.litsp__&#x27;
const NONESCAPEDSPACES_REGEX = /([^\\])\s/g
const LANG = &#x27;lang&#x27;
const ATTR = &#x27;attribute&#x27;
const TAG = &#x27;tag&#x27;
const DIREC = &#x27;directive&#x27;
const FILENAME = &#x27;filename&#x27;
const URI = &#x27;uri&#x27;
const UNKNOWN = &#x27;unknown&#x27;

const isListType = t =&gt; [TAG,DIREC,UNKNOWN].indexOf(t) &gt;= 0

export default function (...args) {
    return (tree) =&gt; visit( tree, &#x27;code&#x27;, transform )
}

function transform (node, index, parent) {  
    console.log( &#x27;[CodeBlocks] Visiting: &#x27;, node.lang, node.meta)
    const litMeta = parseMeta(node)
    
    node.data = {
        ...node.data,
        meta: litMeta,
        hProperties: {
            className: litMeta &amp;&amp; litMeta.tags ? litMeta.tags.map( t =&gt; `tag-${t}`).join(&#x27; &#x27;) : &#x27;&#x27;,
            meta: litMeta,
        }
    }
    return node
}


function parseMeta (node) {
    const raw = `${node.lang || &#x27;&#x27;} ${node.meta || &#x27;&#x27;}`.trim()
    console.log(`[CodeBlocks] lang: &quot;${node.lang}&quot; meta: &quot;${node.meta}&quot;, raw: &quot;${raw}&quot;`)

    const isOutput = raw.indexOf(&#x27;&gt;&#x27;) === 0
    const hasOutput = node.meta &amp;&amp; node.meta.indexOf(&#x27;&gt;&#x27;) &gt;= 0
    let hasSource = node.meta &amp;&amp; node.meta.indexOf(&#x27;&lt;&#x27;) &gt;= 0

    let input = raw
    let _, output, source
    let fromSource;

    if (isOutput) {
        [_, input] = raw.split(&#x27;&gt;&#x27;).map( x =&gt; x.trim() )
    } else {
      if (hasOutput) {
        [input, output] = raw.split(&#x27;&gt;&#x27;).map( x =&gt; x.trim() )
      }

      if (hasSource) {
        [input,source] = input.split(&#x27;&lt;&#x27;).map( x =&gt; x.trim() )
        source = getSource(source)
      }
    }

    const meta = input
        .replace(NONESCAPEDSPACES_REGEX, &quot;$1&quot; + LSP)
        .split(LSP)
        .map(ident)
        .reduce(reduceParts, {})
    
    meta.isOutput = isOutput
    meta.output = output
    meta.hasOutput = !!output
    meta.hasSource = !!source
    meta.source = source
    meta.raw = raw
    if (source) meta.fromSource = source.filename || source.uri

    return meta
}

function getSource(source) {
    if (source) {
        return parseMeta({ lang: &#x27;txt&#x27;, meta: source })
    }
}

function isUri(str) {
  return str.startsWith(&#x27;http&#x27;) || str.startsWith(&#x27;//&#x27;)
}

function ident (x, i) {
    let type, value = x
    if (i === 0) {
      type = LANG
    }
    else if(x &amp;&amp; x[0]) {
      if (x[0] === &quot;#&quot;) {
        type = TAG
        value = x.slice(1)
      }
      else if (x[0] === &quot;!&quot;) {
        type = DIREC
        value = x.slice(1)
      }
      else if (x.indexOf(&quot;=&quot;) &gt; 0) {
        type = ATTR
        value = x.split(&quot;=&quot;)
        value = {
          type: value[0],
          value: value[1]
        }
      }
      else if(i===1) {

        if (isUri(x)) type = URI
        else type = FILENAME
      }
      else if (!type) type = UNKNOWN
    }
    return {type, value}
  }
  
  function reduceParts(memo,item, i) {
    memo.attrs = memo.attrs || {}

    if (item.type === ATTR){
        memo.attrs[item.value.type] = item.value.value
        item = item.value
    }

    if (isListType(item.type)) {
        const collective = `${item.type}s`
        if(memo[collective]) {
             memo[collective]
             .push(item.value)
        } else {
            memo[collective] = [item.value]
        }
        if (item.type === DIREC) {
            // memo.attrs[item.value] = true
        }
    } else {
        memo[item.type] = item.value
    }
    
    return memo
}
  


</code></pre></codecell></div></cell></section>
<section depth="3" class="" startpos="53:1-879" endpos="58:4-951"><cell startpos="53:1-879" endpos="55:17-916"><div class="cell-content"><h3 id="markdown-blocks">Markdown blocks</h3><p><em>Implementation</em></p></div></cell><cell startpos="57:1-918" endpos="58:4-951" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; mdblocks.js</span></span><pre><code class="js">
import visit from &#x27;unist-util-visit&#x27;
import {getConsoleForNamespace} from &#x27;../utils/console&#x27;

const console = getConsoleForNamespace(&#x27;mdblocks&#x27;)

export const mdblocks = function ({baseProcessor}) {
    return async (tree, file) =&gt; {
        file.data = file.data || {}
        file.data.__mdcodeblocks = 0
        const promises = [];
        visit(tree, &#x27;code&#x27;, (node,index,parent) =&gt; {
            if (!node.data || !node.data.meta || node.data.meta.lang !== &#x27;md&#x27;) return;

            const idx = file.data.__mdcodeblocks++
            // instead of await (why?)
            const p = new Promise(async resolve =&gt; {
                // console.log(idx + &quot;Node: &quot;, node)
                const p = baseProcessor()
                const parsed = await p.parse( node.value )
                const ast = await p.run(parsed)
                //  console.log(idx + &quot; AST: &quot;, ast)
                node.children = ast.children
                resolve()
            });
           
            promises.push(p)
        });
        await Promise.all(promises);
        return null
    }
}
</code></pre></codecell></div></cell></section>
<section depth="3" class="" startpos="60:1-954" endpos="65:4-1013"><cell startpos="60:1-954" endpos="62:17-981"><div class="cell-content"><h3 id="links">Links</h3><p><em>Implementation</em></p></div></cell><cell startpos="64:1-983" endpos="65:4-1013" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; links.js</span></span><pre><code class="js">import path from &#x27;path&#x27;
import visit from &#x27;unist-util-visit&#x27;
import { getConsoleForNamespace } from &#x27;../utils/console&#x27;

const console = getConsoleForNamespace(&#x27;links&#x27;, {disabled: true})

export const resolveLinks = (options = { litroot: &#x27;&#x27;, filepath: &#x27;&#x27;}) =&gt; (...args) =&gt; tree =&gt; {
    console.log(&#x27;[Links] Init&#x27;, options)
    return visit(tree, isLink, transform(options))
}

const isLink = (node) =&gt; [&#x27;link&#x27;, &#x27;wikiLink&#x27;].indexOf(node.type) &gt;= 0

const transform = options =&gt; (node, index, parent) =&gt; {
    return decorateLinkNode(node, options.litroot, options.filepath)
}

export const wikiLinkOptions = files =&gt; ({
     pageResolver: (name) =&gt; [
       name.replace(/[^\w\s/-]+/g,&#x27;&#x27;)
           .trim()
           .replace(/\s+/g, &#x27;_&#x27;)
           .toLowerCase()
     ],
})
// ({ 
//     permalinks: files,
//     pageResolver: nameToPermalinks,
//     hrefTemplate: (permalink) =&gt; `${permalink}?file=${permalink}`
// })

const linkToUrl = (link, root) =&gt; {
    if (link.type === &#x27;wikiLink&#x27;) {
        const [base,frag] = link.data.permalink.split(&quot;#&quot;)
        return `${root}${base}.lit${frag ? (&#x27;#&#x27; + frag) : &#x27;&#x27;}`
    } else {
        return link.url
    }
}

export const decorateLinkNode = (link, root = &#x27;&#x27;, filepath = &#x27;&#x27;) =&gt; {
    // console.log(link)
    const wikilink = link.type === &#x27;wikiLink&#x27;
    const url = linkToUrl(link, root)

    // console.log(`[Links] resolving (${link.type}) [${url}] &#x27;${root}&#x27;, &quot;${filepath}&quot;`)
    const isAbsolute = /(https?\:)?\/\//.test(url)
    const isFragment = /^(\?|#).*/.test(url)
    const isRelative = url &amp;&amp; !isAbsolute &amp;&amp; !isFragment

    let canonical = url
    let href = url
    let [base,frag] = url.split(/(\?|#)/)

    if (isRelative) {
        const abs = path.resolve(root, path.dirname(filepath), url)
        canonical = path.relative(path.resolve(root), abs)
        href = url.replace(/\.(md|lit)/i, &#x27;.html&#x27;)
    }

    link.type = &#x27;link&#x27;
    link.url = href
    link.title = link.title || link.value
    link.data = {
        isAbsolute,
        isFragment,
        isRelative,
        canonical,
        wikilink,
    }

    if (wikilink) {
        [base,frag] = link.url.split(&quot;#&quot;)
        link.url = base + &#x27;?file=&#x27; + canonical + (frag ? `#${frag}` : &#x27;&#x27;)
        link.children = [{position: link.position, type: &#x27;text&#x27;, value: link.value }]
    }

    link.data.hProperties = {
        wikilink,
        data: {
             base, 
             frag,
             isAbsolute,
             isFragment,
             isRelative,
             canonical,
             wikilink,
        }
    }
    
    delete link.value

    return link
}

export const nameToPermalinks = (name) =&gt; {
    const full = name.replace(/ /g, &#x27;_&#x27;).toLowerCase()
    const tail = path.basename(full)

    return [&#x27;.lit&#x27;, &#x27;md&#x27;].flatMap( ext =&gt; [full + ext, tail + ext])
    return [full+&#x27;.lit&#x27;, full+&#x27;.md&#x27;, tail+&#x27;.lit&#x27;, tail+&#x27;.md&#x27;]
}
export const nodeMappings = (files) =&gt; {
    const mappings = {}
    files.forEach( (filepath) =&gt; {

    })
    return mappings;
}

</code></pre></codecell></div></cell></section>
<section depth="2" class="" startpos="67:1-1015" endpos="67:17-1031"><cell startpos="67:1-1015" endpos="67:17-1031"><div class="cell-content"><h2 id="ast-to-string">AST to String</h2></div></cell></section></div></div><div id="backlinks"><h4>Backlinks (1)</h4><ol><li><a title=".lit" href="/index.html">.lit</a></li></ol></div><script src="//cdn.jsdelivr.net/npm/eruda"></script><script>eruda.init();</script><script src="/web.bundle.js"></script></body></html>