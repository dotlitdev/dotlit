<html data-reactroot=""><head><title>Parser</title><meta name="litsrc" value="/parser/parser.lit"/><meta name="litroot" value="/"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/><link rel="stylesheet" href="/style.css"/></head><body><div id="lit-app"><div id="lit-header"><menu class="horizontal open has-children"><li class="MenuTitle"><a href="/">Home</a></li><li class="MenuItems"><menu class="has-children" disabled=""><li class="MenuTitle">File</li></menu><menu class="has-children" disabled=""><li class="MenuTitle">Cell</li></menu><menu class="has-children" disabled=""><li class="MenuTitle">Section</li></menu><menu class="has-children" disabled=""><li class="MenuTitle">Help</li></menu><menu class="has-children right"><li class="MenuTitle"><span class="led led-grey"></span><span class="led led-grey"></span><span class="led led-grey"></span></li></menu></li></menu></div><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.0.0/build/styles/sunburst.min.css"/><div id="content"><section id="parser" depth="1" class="" startpos="1:1-0" endpos="5:21-185"><cell startpos="1:1-0" endpos="3:154-163"><div class="cell-content"><h1>Parser</h1><p>Built atop the <a class="local" href="../unified.html" title="unified" wikilink="true" filepath="/parser/parser.lit" root="" data="[object Object]" canonical="/unified.lit">unified</a> ecosystem, specifically <a class="local" href="../remark.html" title="remark" wikilink="true" filepath="/parser/parser.lit" root="" data="[object Object]" canonical="/remark.lit">remark</a>, which takes <code>.lit</code> <a class="local" href="../markdown.html" title="Markdown" wikilink="true" filepath="/parser/parser.lit" root="" data="[object Object]" canonical="/markdown.lit">Markdown</a> source and outputs <code>mdast</code> (Markdown Abstract Syntax Tree)</p></div></cell><section id="table-of-contents" depth="2" class="" startpos="5:1-165" endpos="5:21-185"><cell startpos="5:1-165" endpos="5:21-185"><div class="cell-content"><h2>Table of Contents</h2><ul>
<li>
<p><a class="fragment" href="#implementation-1" filepath="/parser/parser.lit" root="" data="[object Object]" canonical="#implementation-1">Implementation<span class="linkIcon">§</span></a></p>
</li>
<li>
<p><a class="fragment" href="#extensions" filepath="/parser/parser.lit" root="" data="[object Object]" canonical="#extensions">Extensions<span class="linkIcon">§</span></a></p>
<ul>
<li><a class="fragment" href="#frontmatter" filepath="/parser/parser.lit" root="" data="[object Object]" canonical="#frontmatter">Frontmatter<span class="linkIcon">§</span></a></li>
<li><a class="fragment" href="#sections" filepath="/parser/parser.lit" root="" data="[object Object]" canonical="#sections">Sections<span class="linkIcon">§</span></a></li>
<li><a class="fragment" href="#cells" filepath="/parser/parser.lit" root="" data="[object Object]" canonical="#cells">Cells<span class="linkIcon">§</span></a></li>
<li><a class="fragment" href="#codeblocks" filepath="/parser/parser.lit" root="" data="[object Object]" canonical="#codeblocks">Codeblocks<span class="linkIcon">§</span></a></li>
<li><a class="fragment" href="#markdown-blocks" filepath="/parser/parser.lit" root="" data="[object Object]" canonical="#markdown-blocks">Markdown blocks<span class="linkIcon">§</span></a></li>
<li><a class="fragment" href="#links" filepath="/parser/parser.lit" root="" data="[object Object]" canonical="#links">Links<span class="linkIcon">§</span></a></li>
</ul>
</li>
<li>
<p><a class="fragment" href="#ast-to-string" filepath="/parser/parser.lit" root="" data="[object Object]" canonical="#ast-to-string">AST to String<span class="linkIcon">§</span></a></p>
</li>
</ul></div></cell></section></section>
<section id="implementation-1" depth="2" class="" startpos="13:1-312" endpos="16:4-374"><cell startpos="13:1-312" endpos="13:19-330"><div class="cell-content"><h2>Implementation</h2></div></cell><cell startpos="15:1-332" endpos="16:4-374" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; index.js</span></span><pre><code class="js">import unified from &#x27;unified&#x27;
import markdown from &#x27;remark-parse&#x27;
import remarkStringify from &#x27;remark-stringify&#x27;
import slug from &#x27;remark-slug&#x27;
import headingIds from &#x27;remark-heading-id&#x27;
import toc from &#x27;remark-toc&#x27;
import footnotes from &#x27;remark-footnotes&#x27;
import gfm from &#x27;remark-gfm&#x27;
import wikiLinkPlugin from &#x27;remark-wiki-link&#x27;
import select from &#x27;unist-util-select&#x27;
import { to_string } from &#x27;./utils/mdast-util-to-string&#x27;
import toMarkdown from &#x27;mdast-util-to-markdown&#x27;

import {sections, ungroupSections} from &#x27;./sections&#x27;
import codeblocks, {parseMeta, metaToString} from &#x27;./codeblocks&#x27;
import frontmatter from &#x27;./frontmatter&#x27;
import {mdblocks} from &#x27;./mdblocks&#x27;
import links, { decorateLinkNode } from &#x27;./links&#x27;
import { getConsoleForNamespace} from &#x27;../utils/console&#x27;

import {time} from &#x27;../utils/timings&#x27;

//import { transform as jsTransform } from &#x27;./transformers/js&#x27;

const jsTransform = null
const console = getConsoleForNamespace(&#x27;parser&#x27;)

const timer = () =&gt; ({ns, marker}) =&gt; (t,f) =&gt; { time(ns,marker) }

const baseProcessor = ({litroot, files} = {}) =&gt; {
    return unified()
    .use(timer(),{ns:&#x27;parser&#x27;})
    .use((...args) =&gt; (tree, file) =&gt; {
        console.log(&quot;Parsing file: &quot;, file.path)
        file.data = file.data || {}
        if (file &amp;&amp; file.path) {
            file.data.canonical = decorateLinkNode({url: file.path}, &#x27;&#x27;, &#x27;/&#x27;, files).data.canonical
        }
    })

    // remark
    .use(markdown, {})
    .use(gfm)
    .use(frontmatter, {})

    // Extact title
    .use((...args) =&gt; (tree,file) =&gt; {
        if(!file.data.frontmatter || !file.data.frontmatter.title) {
           
           file.data = file.data || {}
           file.data.frontmatter = file.data.frontmatter || {}
           const heading = select.select(&#x27;heading&#x27;, tree)
           // console.log(&quot;Found heading:&quot;, heading)
           if (heading) {
               console.log(&quot;No title in frontmatter, extracting heading.&quot;)
               const title = to_string(heading)
               file.data.frontmatter.title = title
           }
        }
    },{})

    .use(wikiLinkPlugin, links.wikiLinkOptions(files))
    .use(slug)
    .use(toc, {})
    .use(headingIds)
    .use(footnotes, {inlineNotes: true})

    .use(timer(),{ns:&#x27;parser&#x27;, marker: &#x27;baseProcessorComplete&#x27;})
}

export const processor = ({files, fs, litroot} = {files: []}) =&gt; {
    console.log(`Setting up processor litroot: &quot;${litroot}&quot; files: ${!!files} fs: ${!!fs}`)
    return baseProcessor({files, litroot})
    // remark-litmd (rehype compatable)

    .use(codeblocks)
    // Async reparse `md` codeblocks as children
    .use(mdblocks, {baseProcessor, litroot, files})
    .use(links.resolveLinks({litroot, files}))

    .use(sections, {})
    .use(timer(),{ns:&#x27;parser&#x27;, marker: &#x27;processorComplete&#x27;})
}

export const utils = {
  mdblocks,
  sections, ungroupSections,
  links,
  codeblocks, parseMeta, metaToString,
  remarkStringify,
  to_string,
  toMarkdown,
  frontmatter,
}

export async function parse(vfile, options) {
    const p = processor(options)
    const parsed = await p.parse( vfile )
    const ast = await p.run(parsed)
    if (!parsed.data) parsed.data = {}
    parsed.data.ast = ast
    // parsed.data.frontmatter = select.selectAll(&#x27;html&#x27;,ast).reduce( (memo,el) =&gt; Object.assign(memo,el.data || {}),{})
    return parsed
}

export const transformers = {
    jsx: jsTransform,
}


export function stringify(vfile) {
    return processor()
        .use(ungroupSections())
        .use(remarkStringify, {
            bullet: &#x27;-&#x27;,
            // handlers: {
            //     cell: debugAstToMarkdown,
            //     section: debugAstToMarkdown
            // }
        })
        .process(vfile)
}

</code></pre></codecell></div></cell></section>
<section id="extensions" depth="2" class="" startpos="18:1-376" endpos="23:4-460"><cell startpos="18:1-376" endpos="18:14-389"><div class="cell-content"><h2>Extensions</h2></div></cell><section id="frontmatter" depth="3" class="" startpos="19:1-390" endpos="23:4-460"><cell startpos="19:1-390" endpos="20:17-422"><div class="cell-content"><h3>Frontmatter</h3><p><em>Implementation</em></p></div></cell><cell startpos="22:1-424" endpos="23:4-460" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; frontmatter.js</span></span><pre><code class="js">import visit from &#x27;unist-util-visit&#x27;
import before from &#x27;unist-util-find-before&#x27;
import after from &#x27;unist-util-find-after&#x27;
import yaml from &#x27;js-yaml&#x27;

import {log, level} from &#x27;../utils/console&#x27;
import { notEqual } from &#x27;assert&#x27;
import { getConsoleForNamespace } from &#x27;../utils/console&#x27;

const console = getConsoleForNamespace(&#x27;frontmatter&#x27;)

const FRONTMATTER_OPEN = &#x27;&lt;!-- data&#x27;
const FRONTMATTER_CLOSE = &#x27;--&gt;&#x27;

export default function (...args) {
    return (tree,file) =&gt; {
        const matters = []
        visit( tree, &#x27;html&#x27;, (node, index, parent) =&gt; {  
            if (node.value.indexOf(FRONTMATTER_OPEN) === 0 &amp;&amp; node.value.indexOf(FRONTMATTER_CLOSE) === (node.value.length - FRONTMATTER_CLOSE.length)) {
                console.log( &#x27;Raw&#x27;, node.value)
                const yamlString = node.value.slice(FRONTMATTER_OPEN.length, node.value.length - FRONTMATTER_CLOSE.length).trim()
                try {
                    node.data = yaml.load(yamlString, &#x27;utf8&#x27;)
                } catch(err) {
                    node.data = {error: err.toString()}
                }
               console.log( &#x27;Parsed&#x27;, yamlString)
               matters.push(node.data)
            }
        })
        file.data.frontmatter = matters.reduce( (memo,matter) =&gt; Object.assign({}, memo, matter || {}), {})
    }
}


</code></pre></codecell></div></cell></section></section>
<section id="sections" depth="3" class="" startpos="25:1-462" endpos="41:4-735"><cell startpos="25:1-462" endpos="27:74-549"><div class="cell-content"><h3>Sections</h3><p>Sections are automatically created from the nested structure of Headings.</p></div></cell><cell startpos="29:1-551" endpos="32:4-614" class="code"><div class="cell-content"><codecell class="lang-md local"><span class="meta"><span class="lang">md</span></span><pre><code class="md"># Headline (root section)
## Subtitle (child section)
</code></pre></codecell></div></cell><cell startpos="34:1-616" endpos="34:34-649"><div class="cell-content"><p>They can be collapse/folded (tbd)</p></div></cell><cell startpos="36:1-651" endpos="38:4-684" class="code"><div class="cell-content"><codecell class="lang-md local"><span class="meta"><span class="lang">md</span></span><pre><code class="md"># &gt;Headline (collapsed)
</code></pre></codecell></div></cell><cell startpos="39:1-685" endpos="39:17-701"><div class="cell-content"><p><em>Implementation</em></p></div></cell><cell startpos="40:1-702" endpos="41:4-735" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; sections.js</span></span><pre><code class="js">import heading from &quot;mdast-util-heading-range&quot;;
import visit from &quot;unist-util-visit&quot;;
import flatMap from &quot;unist-util-flatmap&quot;;
import { getConsoleForNamespace } from &#x27;../utils/console&#x27;
import { Identity } from &quot;../utils/functions&quot;;

const console = getConsoleForNamespace(&#x27;sections&#x27;, {disabled: true})

const firstChild = (node,type) =&gt; node.children 
            &amp;&amp; node.children[0]
            &amp;&amp; node.children[0].type === type

const createCell = (node,nodes) =&gt; {
     const pos = node.position
     // pos.start.offset = pos.start.offset - pos.start.column
     // pos.start.column = 0
     return {
          type: &quot;cell&quot;,
          position: pos,
          data: {
            hName: &quot;cell&quot;,
            hProperties: {
              class: &quot;cell&quot;,
            },
          },
          children: nodes || [node],
        }
}

const createSection = (node,nodes) =&gt; {
  if (!nodes) node.children = cellsFromNodes(node.children)
  return {
        type: &quot;section&quot;,
        data: {
          hName: &quot;section&quot;,
        },
        position: node.position,
        children: nodes || [node],
      }
}

const cellsFromNodes = (nodes, {addSectionDataToFirstCell}={}) =&gt; {

  const cells = [];
  let newCell = null;

  nodes.map((current, index) =&gt; {
    const node = current;
    console.log(&quot;[Sections] child: &quot;, index, node.type);

    if (node.type === &quot;section&quot;) {
      newCell = null;
      cells.push(node);

    } else if (false &amp;&amp; node.type === &quot;list&quot; &amp;&amp; node.spread) {
      newCell = null;
      let listSection = createSection(node)
      cells.push(listSection);

    } else if (false &amp;&amp; node.type === &quot;listItem&quot; &amp;&amp; node.spread) {
      newCell = null;
      let listItem = node
      if (firstChild(listItem, &#x27;section&#x27;)) {
        console.log(&quot;[Sections] ListItem with section: &quot;, node.type);
        listItem.children = listItem.children.map( section =&gt; {
          section.children = cellsFromNodes(section.children)
        })
      } else {
        listItem.children = [createSection(node, node.children)]
      }
      
      cells.push(listItem);

    } else if (node.type === &quot;code&quot;) {
      const next = nodes[index+1]
      const attached = node =&gt; node &amp;&amp; node.data &amp;&amp; node.data.meta &amp;&amp; node.data.meta.attached
      const nextIsAttached = attached(next)
                            
      let singleCell = createCell(node)
      if (nextIsAttached) {
          newCell = singleCell
         
      } else if (newCell &amp;&amp; attached(node)) {
          newCell.children.push(node)
          if (node.position) newCell.position.end = node.position.end;
          cells.push(newCell)
          newCell = null

      } else {
          newCell = null
          cells.push(singleCell);
      }
     
     
      
    } else if (newCell) {
      newCell.children.push(node);
      if (node.position) newCell.position.end = node.position.end;

    } else {
      newCell = createCell(node)
      if(addSectionDataToFirstCell) newCell.data.section = addSectionDataToFirstCell
      cells.push(newCell);
    }
  });
  return cells;

}

export const sections = (...args) =&gt; (tree) =&gt; {
  console.log(&#x27;[Sections II] Init.&#x27;, args, tree.type, tree.children.length)
  let headings = 0
  const newSection = (children) =&gt; {
    const first = children[0]
    const last = children[ children.length - 1]
    const depth = first.depth || 0
    first.processed = true
    return {
      type: &#x27;section&#x27;,
      data: {
        name: first.data.id,
        hName: &#x27;section&#x27;,
        hProperties: {
          depth: depth,
          id: first.data.id,
        }
      },
      depth: depth,
      children: children,
      position: {
        start: first.position.start,
        end: last.position.end
      }
    }
  }

  visit(tree, &#x27;heading&#x27;, (node, index, parent) =&gt; {
    if (node.processed) {
      console.log(`[Sections II] Ignoring already processed node ${node.data.id}`)
    } else if (parent.type === &#x27;root&#x27;) {
      console.log(`[Sections II] heading &quot;${node.data.id}&quot; ${headings}, depth: ${node.depth}`)
      // remove rehype ids 
      node.data.hProperties = {}
      const section = parent.children[index] = newSection([node])
      const children = parent.children
      
      for (let i = index + 1; i &lt; children.length; i++) {
        if (!children[i] || children[i].processed) {
          console.log(&#x27;Skipping removed&#x27;, children[i])
          break
        }
        const nextNode = children[i]
        if ((nextNode.type === &#x27;heading&#x27; || nextNode.type === &#x27;section&#x27;) &amp;&amp; nextNode.depth &lt;= node.depth) {
          console.log(`[Sections II] ended &quot;${node.data.id}&quot; due to &quot;${nextNode.data.id || nextNode.data.name}&quot;`, nextNode.type, nextNode.depth)
          console.log(`[Sections II] contains: &quot;${node.data.id}&quot;`, section.children.map( n =&gt; n.type).join(&#x27;,&#x27;))
          break;
        }
        console.log(`[Sections II] child index: ${i}, type: ${nextNode.type} depth: ${nextNode.depth} id: ${nextNode.data &amp;&amp; (nextNode.data.id || nextNode.data.name)}`)
        section.children.push(nextNode)
        if (nextNode.position) section.position.end = nextNode.position.end
        delete parent.children[i]
      }
      headings++
      node = section 
      node.children = cellsFromNodes(node.children, {addSectionDataToFirstCell: { id: section.data.id, position: section.position}})
    } else {
      console.log(&#x27;[Sections II] WARN: Header parent not root&#x27;, node.data.id)
    }
  }, true)

  console.log(&quot;Headings: &quot;, headings)
  if (!headings) {
    tree.children = cellsFromNodes(tree.children)
  } else {
    tree.children = tree.children.filter(Identity)
  }
  
}


const cells = (...args) =&gt; (tree) =&gt; {
  visit( tree, cells )
}


export const ungroupSections = (options = {}) =&gt; (...args) =&gt; (tree) =&gt; {
  console.log(&quot;[UnSection] Init&quot;, options)
  tree = flatMap(tree, (node) =&gt; {
    if (node.type === &quot;cell&quot;) {
      return node.children
    } else if (node.type === &quot;section&quot;) {
      return node.children
    } else {
      return [node]
    }
  })
  return tree
}

</code></pre></codecell></div></cell></section>
<section id="cells" depth="3" class="" startpos="43:1-737" endpos="45:60-807"><cell startpos="43:1-737" endpos="45:60-807"><div class="cell-content"><h3>Cells</h3><p><em>Currently implemented as part of <strong>Sections</strong>, see above.</em></p></div></cell></section>
<section id="codeblocks" depth="3" class="" startpos="47:1-809" endpos="101:4-2226"><cell startpos="47:1-809" endpos="49:17-841"><div class="cell-content"><h3>Codeblocks</h3><p><em>Implementation</em></p></div></cell><cell startpos="51:1-843" endpos="52:4-878" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; codeblocks.js</span></span><pre><code class="js">import visit from &#x27;unist-util-visit&#x27;
import { getConsoleForNamespace } from &#x27;../utils/console&#x27;

const console = getConsoleForNamespace(&#x27;codeblocks&#x27;)

const LSP = &#x27;__.litsp__&#x27;
const NONESCAPEDSPACES_REGEX = /([^\\])\s/g
const LANG = &#x27;lang&#x27;
const ATTR = &#x27;attribute&#x27;
const TAG = &#x27;tag&#x27;
const DIREC = &#x27;directive&#x27;
const FILENAME = &#x27;filename&#x27;
const URI = &#x27;uri&#x27;
const UNKNOWN = &#x27;unknown&#x27;

const isListType = t =&gt; [TAG,DIREC,UNKNOWN].indexOf(t) &gt;= 0

export default function (...args) {
    return (tree) =&gt; visit( tree, &#x27;code&#x27;, transform )
}

function transform (node, index, parent) {  
    console.log( &#x27;[CodeBlocks] Visiting: &#x27;, node.lang, node.meta)
    const litMeta = parseMeta(node)
    
    node.data = {
        ...node.data,
        meta: litMeta,
        hProperties: {
            className: litMeta &amp;&amp; litMeta.tags ? litMeta.tags.map( t =&gt; `tag-${t}`).join(&#x27; &#x27;) : &#x27;&#x27;,
            meta: litMeta,
        }
    }
    return node
}


export const parseMeta = function parseMeta (node) {
    const raw = `${node.lang || &#x27;&#x27;} ${node.meta || &#x27;&#x27;}`.trim()
    console.log(`[CodeBlocks] lang: &quot;${node.lang}&quot; meta: &quot;${node.meta}&quot;, raw: &quot;${raw}&quot;`)

    const isOutput = raw.indexOf(&#x27;&gt;&#x27;) === 0
    const hasOutput = node.meta &amp;&amp; node.meta.indexOf(&#x27;&gt;&#x27;) &gt;= 0
    let hasSource = node.meta &amp;&amp; node.meta.indexOf(&#x27;&lt;&#x27;) &gt;= 0

    let input = raw
    let _, output, source
    let fromSource;

    if (isOutput) {
        [_, input] = raw.split(&#x27;&gt;&#x27;).map( x =&gt; x.trim() )
    }

      if (hasOutput) {
        [input, output] = input.split(&#x27;&gt;&#x27;).map( x =&gt; x.trim() )
      }

      if (hasSource) {
        [input,source] = input.split(&#x27;&lt;&#x27;).map( x =&gt; x.trim() )
      }

    const meta = input
        .replace(NONESCAPEDSPACES_REGEX, &quot;$1&quot; + LSP)
        .split(LSP)
        .map(ident)
        .reduce(reduceParts, {})
    
    meta.isOutput = isOutput
    meta.output = output &amp;&amp; parseMeta({ meta: output })
    meta.hasOutput = !!output
    meta.hasSource = !!source
    meta.source = source &amp;&amp; parseMeta({ lang: &#x27;txt&#x27;, meta: source })
    meta.raw = raw
    if (meta.source) meta.fromSource = meta.source.filename || meta.source.uri

    return meta
}

function isUri(str) {
  return str.startsWith(&#x27;http&#x27;) || str.startsWith(&#x27;//&#x27;)
}

function ident (x, i) {
    let type, value = x
    if (i === 0) {
      type = LANG
    }
    else if(x &amp;&amp; x[0]) {
      if (x[0] === &quot;#&quot;) {
        type = TAG
        value = x.slice(1)
      }
      else if (x[0] === &quot;!&quot;) {
        type = DIREC
        value = x.slice(1)
      }
      else if (x.indexOf(&quot;=&quot;) &gt; 0) {
        type = ATTR
        value = x.split(&quot;=&quot;)
        value = {
          type: value[0],
          value: value[1]
        }
      }
      else if(i===1) {

        if (isUri(x)) type = URI
        else type = FILENAME
      }
      else if (!type) type = UNKNOWN
    }
    return {type, value}
  }
  
  function reduceParts(memo,item, i) {
    memo.attrs = memo.attrs || {}

    if (item.type === ATTR){
        memo.attrs[item.value.type] = item.value.value
        item = item.value
    }

    if (isListType(item.type)) {
        const collective = `${item.type}s`
        if(memo[collective]) {
             memo[collective]
             .push(item.value)
        } else {
            memo[collective] = [item.value]
        }
        if (item.type === DIREC) {
            // memo.attrs[item.value] = true
        }
    } else {
        memo[item.type] = item.value
    }
    
    return memo
}
  

export const metaToString = (meta) =&gt; {

  const prefix = p =&gt; str =&gt; p + str
  const tag = prefix(&quot;#&quot;)
  const dir = prefix(&quot;!&quot;)
  const attr = ([key,value]) =&gt; `${key}=${value}`

  const parts = [];
  const dirs = meta.directives || []
  const tags = meta.tags || []
  const attrs = meta.attrs || {}

  parts.push(meta.isOutput &amp;&amp; &quot;&gt;&quot;);
  parts.push(meta.lang);
  parts.push(meta.filename || meta.uri);
  
  dirs.forEach( d =&gt; parts.push(dir(d)))
  Object.entries(attrs).forEach( (e) =&gt; parts.push(attr(e)))
  tags.forEach( t =&gt; parts.push(tag(t)))

  if (meta.source) {
    parts.push(&quot;&lt;&quot;)
    parts.push(metaToString(meta.source))
  }

  if (meta.output) {
    parts.push(&quot;&gt;&quot;)
    parts.push(metaToString(meta.output))
  }

  return parts.filter((x) =&gt; x).join(&quot; &quot;);
};

</code></pre></codecell></div></cell><cell startpos="53:1-879" endpos="101:4-2226" class="code"><div class="cell-content"><codecell class="tag-meta tag-tostring lang-js local"><span class="meta"><span class="lang">js</span><span style="color:white;background-color:#033165" class="tag">meta</span><span style="color:black;background-color:#ccb166" class="tag">tostring</span></span><pre><code class="js">const metaToString = lit.parser.utils.metaToString;

const input =
  &quot;js index.jsx !foo #bar baz=qux\\ zig &lt; source.jsx &gt; json output.json #faz !raz&quot;;
const meta = lit.parser.utils.parseMeta({ meta: input });
console.log(input);
console.log(meta);
return metaToString(meta);
return lit.parser.utils;

</code></pre></codecell><codecell class="lang-txt local output"><span class="meta"><span class="lang">txt</span><span class="updatedAt">Updated <span class="Time relative">48.3w ago</span></span></span><output><pre><code class="txt">js index.jsx !foo #bar baz=qux\ zig &lt; source.jsx &gt; json output.json #faz !raz
{ attrs: { baz: &#x27;qux\\ zig&#x27; },
  lang: &#x27;js&#x27;,
  filename: &#x27;index.jsx&#x27;,
  directives: [ &#x27;foo&#x27; ],
  tags: [ &#x27;bar&#x27; ],
  baz: &#x27;qux\\ zig&#x27;,
  isOutput: false,
  output: 
   { attrs: {},
     lang: &#x27;json&#x27;,
     filename: &#x27;output.json&#x27;,
     tags: [ &#x27;faz&#x27; ],
     directives: [ &#x27;raz&#x27; ],
     isOutput: false,
     output: undefined,
     hasOutput: false,
     hasSource: false,
     source: undefined,
     raw: &#x27;json output.json #faz !raz&#x27; },
  hasOutput: true,
  hasSource: true,
  source: 
   { attrs: {},
     lang: &#x27;txt&#x27;,
     filename: &#x27;source.jsx&#x27;,
     isOutput: false,
     output: undefined,
     hasOutput: false,
     hasSource: false,
     source: undefined,
     raw: &#x27;txt source.jsx&#x27; },
  raw: &#x27;js index.jsx !foo #bar baz=qux\\ zig &lt; source.jsx &gt; json output.json #faz !raz&#x27;,
  fromSource: &#x27;source.jsx&#x27; }
js index.jsx !foo baz=qux\ zig #bar &lt; txt source.jsx &gt; json output.json !raz #faz
</code></pre></output></codecell></div></cell></section>
<section id="markdown-blocks" depth="3" class="" startpos="104:1-2229" endpos="109:4-2301"><cell startpos="104:1-2229" endpos="106:17-2266"><div class="cell-content"><h3>Markdown blocks</h3><p><em>Implementation</em></p></div></cell><cell startpos="108:1-2268" endpos="109:4-2301" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; mdblocks.js</span></span><pre><code class="js">import visit from &#x27;unist-util-visit&#x27;
import {getConsoleForNamespace} from &#x27;../utils/console&#x27;
import vfile from &#x27;vfile&#x27;

const console = getConsoleForNamespace(&#x27;mdblocks&#x27;)

export const mdblocks = function ({baseProcessor, files, litroot}) {
    return async (tree, file) =&gt; {
        file.data = file.data || {}
        file.data.__mdcodeblocks = 0
        const filepath = file?.data?.canonical || &#x27;inexplicable.ext&#x27;
        const promises = [];
        visit(tree, &#x27;code&#x27;, (node,index,parent) =&gt; {
            if (!node.data || !node.data.meta || node.data.meta.lang !== &#x27;md&#x27;) return;

            const idx = file.data.__mdcodeblocks++
            // instead of await (why?)
            const p = new Promise(async resolve =&gt; {
                // console.log(idx + &quot;Node: &quot;, node)
                const mdfile = await vfile({path: filepath, contents: node.value})
                const p = baseProcessor({files, litroot})
                const parsed = await p.parse( mdfile )
                const ast = await p.run(parsed, mdfile)
                console.log(idx + &quot;MD AST: &quot;, filepath, mdfile, ast)
                node.children = ast.children
                resolve()
            });
           
            promises.push(p)
        });
        await Promise.all(promises);
        return null
    }
}

</code></pre></codecell></div></cell></section>
<section id="links" depth="3" class="" startpos="111:1-2304" endpos="116:4-2363"><cell startpos="111:1-2304" endpos="113:17-2331"><div class="cell-content"><h3>Links</h3><p><em>Implementation</em></p></div></cell><cell startpos="115:1-2333" endpos="116:4-2363" class="code"><div class="cell-content"><codecell class="dir-collapse lang-js local collapsed"><span class="meta"><span class="lang">js</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; links.js</span></span><pre><code class="js">import {join, resolve, relative, dirname} from &quot;path&quot;;
import visit from &quot;unist-util-visit&quot;;
import { getConsoleForNamespace } from &quot;../utils/console&quot;;

const console = getConsoleForNamespace(&quot;links&quot;);

export const resolveLinks =
  (options = { litroot: &quot;&quot;, filepath: &quot;&quot;, files: []}) =&gt;
  (...args) =&gt;
  (tree, file) =&gt; {
    // console.log(&quot;[Links] Init&quot;, file.path, options);
    options.filepath = options.filepath || file?.data?.canonical || file.path
    return visit(tree, isLink, transform(options));
  };

export const slug = (str) =&gt;
  str
    .replace(/[^\w\s/-]+/g, &quot;&quot;)
    .trim()
    .replace(/\s+/g, &quot;_&quot;)
    .toLowerCase();

export const resolver = (str) =&gt; {
  // console.log(&quot;Input: &quot;, str);
  if (!str) {
    throw Error(&quot;No string to resolve&quot;)
    process.exit(1)
  }
  let main, title, doc, hash, base, query, file, ext, _
  try {
    [main, title] = str.split(&quot;|&quot;);
    [doc, hash] = main.split(&quot;#&quot;);
    [base, query] = doc.split(&quot;?&quot;);
    [_, file, ext = &#x27;&#x27;] = base.match(/([^\.]+)(\.[a-zA-Z0-9]+)?$/) || []
  } catch(err) {
    console.log({str, main, title, doc, hash, base, query, file, ext, _})
    console.log(&#x27;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#x27;, err)
    process.exit(1)
  }
  
 
  const root = file &amp;&amp; file[0] &amp;&amp; [&#x27;/&#x27;, &#x27;.&#x27;].indexOf(file[0]) &gt;= 0 ? &#x27;&#x27; : &#x27;/&#x27;
  const path = file &amp;&amp; (root + slug(file))
  const section = hash &amp;&amp; slug(hash);

  const href = path + (query ? &quot;?&quot; + query : &quot;&quot;) + (hash ? &quot;#&quot; + section : &quot;&quot;);
  // console.log(&#x27;Href: &#x27;, href)
  return { title, path, ext, hash, query, section, href };
};


const isLink = (node) =&gt; [&quot;link&quot;, &quot;wikiLink&quot;].indexOf(node.type) &gt;= 0;

const transform = (options) =&gt; (node, index, parent) =&gt; {
  return decorateLinkNode(node, options.litroot, options.filepath, options.files);
};

export const wikiLinkOptions = (files = []) =&gt; {
  return {
    permalinks: files,
    pageResolver: (name) =&gt; {
      // console.log(&#x27;Resolving&#x27;, name)
      const {path, ext} = resolver(name)
      const exts = [&#x27;.lit&#x27;, &#x27;/index.lit&#x27;, &#x27;.md&#x27;, ext]
      const opts = exts.map( ext =&gt; {
        return `${path}${ext}`
      })
      // console.log(opts)
      return opts //.filter(file =&gt; files.indexOf(file) &gt;= 0)[0] || opts
    }
  }
};
// ({
//     permalinks: files,
//     pageResolver: nameToPermalinks,
//     hrefTemplate: (permalink) =&gt; `${permalink}?file=${permalink}`
// })

const linkToUrl = (link, root) =&gt; {
  if (link.type === &quot;wikiLink&quot;) {
    // console.log(link)
    return link.data.permalink
  } else {
    return link.url;
  }
};

export const decorateLinkNode = (link, root = &quot;&quot;, filepath = &quot;&quot;, files = []) =&gt; {
  // console.log(link)
  const wikilink = link.type === &quot;wikiLink&quot;;
  const url = linkToUrl(link, root);

  
  const isExternal = /^(https?\:)?\/\//.test(url);
  const isAbsolute = !isExternal &amp;&amp; /^\//.test(url);
  const isFragment = /^(\?|#)/.test(url);
  const isRelative = url &amp;&amp; !isAbsolute &amp;&amp; !isFragment &amp;&amp; !isExternal;
  
  const srcToGH = (src, prefix) =&gt; join(prefix, src);
  const relToCanonical = (src, link) =&gt; resolve(dirname(src), link);
  const canonicalToRel = (src1, src2) =&gt; relative(dirname(src1), src2)

  let canonical = url;
  let href = url;
  let [base, frag] = url.split(/(\?|#)/);

  if (isRelative) {
    canonical = relToCanonical(filepath, base)
    href = url.replace(/\.(md|lit)/i, &quot;.html&quot;) ;
  } else if (isAbsolute) {
    const rel = canonicalToRel(filepath, url);
    href = rel.replace(/\.(md|lit)/i, &quot;.html&quot;);
  }

  link.type = &quot;link&quot;;
  link.url = href;
  link.title = link.title || link.value;
  const exists = files.indexOf(canonical) &gt;= 0

  const data = {
    isExternal,
    isAbsolute,
    isFragment,
    isRelative,
    canonical,
    wikilink,
    exists,
  };
  link.data = Object.assign({},data,{})

  if (wikilink) {
    link.children = [
      { position: link.position, type: &quot;text&quot;, value: link.value },
    ];
  }

  link.data.hProperties = {
    wikilink,
    filepath,
    root,
    data,
  };

  delete link.value;
  console.log(`[${filepath}] resolving (${link.type}) [${canonical}] exists: ${exists}`, link.url)

  return link;
};


export default {
  resolveLinks,
  wikiLinkOptions,
  resolver,
  linkToUrl,
  decorateLinkNode,
}

</code></pre></codecell></div></cell></section>
<section id="ast-to-string" depth="2" class="" startpos="118:1-2365" endpos="130:4-2888"><cell startpos="118:1-2365" endpos="122:168-2713"><div class="cell-content"><h2>AST to String</h2><ul class="contains-task-list">
<li class="task-list-item">
<p><input type="checkbox" disabled=""/> <!-- -->#TODO refactor save (update src) to operate on AST directly and stringify as below, instead of the cureent <a class="local" href="../utils/unist-patch-source.html" title="../utils/unist-patch-source" wikilink="true" filepath="/parser/parser.lit" root="" data="[object Object]" canonical="/utils/unist-patch-source.lit">../utils/unist-patch-source</a> implementaction.</p>
<p>This is complicated by the fact that new cell source can in effect result in previous and next cell semantic/structure changes, hence the patch source implementation</p>
</li>
</ul></div></cell><cell startpos="123:1-2714" endpos="130:4-2888" class="code"><div class="cell-content"><codecell class="lang-js local"><span class="meta"><span class="lang">js</span></span><pre><code class="js">const {toMarkdown, ungroupSections}
      = lit.parser.utils
const unGroup = ungroupSections()()
const tree = unGroup(lit.ast)
const md = toMarkdown(tree)
return md
</code></pre></codecell></div></cell></section></div></div><div id="backlinks"><h4>Backlinks (2)</h4><ol><li><a title=".lit" href="/index.html">.lit</a></li><li><a title="Links" href="/testing/links.html">Links</a></li></ol></div><script src="//cdn.jsdelivr.net/npm/eruda"></script><script>eruda.init();</script><script async="" src="/web.bundle.js"></script></body></html>