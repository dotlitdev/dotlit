# Parser

Built atop the [[unified]] ecosystem, specifically [[remark]], which takes `.lit` [[Markdown]] source and outputs `mdast` (Markdown Abstract Syntax Tree)

## Table of Contents
#### Implementation

```js !collapse < ./index.js
console.log(lit.ast)
console.log(lit.select.selectAll('code', lit.ast)
```

## Implementation 

```js !collapse remote=true < index.js
```

## Extensions
### Frontmatter
*Implementation*

```js !collapse < frontmatter.js
```

### Sections

Sections are automatically created from the nested structure of Headings.

```md
# Headline (root section)
## Subtitle (child section)
```

They can be collapse/folded (tbd)

```md
# >Headline (collapsed)
```
*Implementation*
```js !collapse < sections.js
```

### Cells

*Currently implemented as part of **Sections**, see above.*

### Codeblocks

*Implementation*

```js !collapse < codeblocks.js
```
### Markdown blocks

*Implementation*

```js !collapse < mdblocks.js
```
 
### Links

*Implementation*

```js !collapse < links.js
```

## AST to String
```js
const {toMarkdown, ungroupSections}
      = lit.parser.utils
const unGroup = ungroupSections()()
const tree = unGroup(lit.ast)
const md = toMarkdown(tree)
return md
```
```>txt attached=true updated=1621460014942
# Parser

Built atop the [unified](/unified.html?file=unified.lit "unified") ecosystem, specifically [remark](/remark.html?file=remark.lit "remark"), which takes `.lit` [Markdown](/markdown.html?file=markdown.lit "Markdown") source and outputs `mdast` (Markdown Abstract Syntax Tree)

## Table of Contents

*   [Implementation](#implementation-1)

*   [Extensions](#extensions)

    *   [Frontmatter](#frontmatter)
    *   [Sections](#sections)
    *   [Cells](#cells)
    *   [Codeblocks](#codeblocks)
    *   [Markdown blocks](#markdown-blocks)
    *   [Links](#links)

*   [AST to String](#ast-to-string)

## Implementation

•••js !collapse remote=true < index.js
import unified from 'unified'
import markdown from 'remark-parse'
import remarkStringify from 'remark-stringify'
import slug from 'remark-slug'
import headingIds from 'remark-heading-id'
import toc from 'remark-toc'
import footnotes from 'remark-footnotes'
import gfm from 'remark-gfm'
import { wikiLinkPlugin } from 'remark-wiki-link'
import select from 'unist-util-select'
import { to_string } from './utils/mdast-util-to-string'
import toMarkdown from 'mdast-util-to-markdown'

import {sections, groupIntoSections, ungroupSections} from './sections'
import codeblocks from './codeblocks'
import frontmatter from './frontmatter'
import {mdblocks} from './mdblocks'
import {resolveLinks, wikiLinkOptions} from './links'
import { getConsoleForNamespace} from '../utils/console'
//import { transform as jsTransform } from './transformers/js'

const jsTransform = null
const console = getConsoleForNamespace('parser')

const baseProcessor = ({litroot, files} = {}) => {
    return unified()

    .use((...args) => (tree, file) => {
        console.log("Parsing file", file.path)
    })

    // remark
    .use(markdown, {})
    .use(gfm)
    .use(frontmatter, {})

    // Extact title
    .use((...args) => (tree,file) => {
        if(!file.data.frontmatter || !file.data.frontmatter.title) {
           
           file.data = file.data || {}
           file.data.frontmatter = file.data.frontmatter || {}
           const heading = select.select('heading', tree)
           // console.log("Found heading:", heading)
           if (heading) {
               console.log("No title in frontmatter, extracting heading.")
               const title = to_string(heading)
               file.data.frontmatter.title = title
           }
        }
    },{})

    .use(wikiLinkPlugin, wikiLinkOptions(files))
    .use(slug)
    .use(toc, {})
    .use(headingIds)
    .use(footnotes, {inlineNotes: true})
}

export const processor = ({files, fs, litroot} = {files: []}) => {
    console.log(`Setting up processor litroot: "${litroot}" files: ${!!files} fs: ${!!fs}`)
    return baseProcessor({files, litroot})
    // remark-litmd (rehype compatable)

    .use(codeblocks)
    // Async reparse `md` codeblocks as children
    .use(mdblocks, {baseProcessor})
    .use(resolveLinks({litroot}))

    .use(sections, {})

}

export const utils = {
  mdblocks,
  sections, ungroupSections,
  resolveLinks,
  codeblocks,
  remarkStringify,
  to_string,
  toMarkdown,
  frontmatter,
}

export async function parse(vfile, options) {
    const p = processor(options)
    const parsed = await p.parse( vfile )
    const ast = await p.run(parsed)
    if (!parsed.data) parsed.data = {}
    parsed.data.ast = ast
    // parsed.data.frontmatter = select.selectAll('html',ast).reduce( (memo,el) => Object.assign(memo,el.data || {}),{})
    return parsed
}

export const transformers = {
    jsx: jsTransform,
}


export function stringify(vfile) {
    return processor()
        .use(ungroupSections())
        .use(remarkStringify, {
            bullet: '-',
            // handlers: {
            //     cell: debugAstToMarkdown,
            //     section: debugAstToMarkdown
            // }
        })
        .process(vfile)
}

•••

## Extensions

### Frontmatter

*Implementation*

•••js !collapse < frontmatter.js
import visit from 'unist-util-visit'
import before from 'unist-util-find-before'
import after from 'unist-util-find-after'
import yaml from 'js-yaml'

import {log, level} from '../utils/console'
import { notEqual } from 'assert'
import { getConsoleForNamespace } from '../utils/console'

const console = getConsoleForNamespace('frontmatter')

const FRONTMATTER_OPEN = '<!-- data'
const FRONTMATTER_CLOSE = '-->'

export default function (...args) {
    return (tree,file) => {
        const matters = []
        visit( tree, 'html', (node, index, parent) => {  
            if (node.value.indexOf(FRONTMATTER_OPEN) === 0 && node.value.indexOf(FRONTMATTER_CLOSE) === (node.value.length - FRONTMATTER_CLOSE.length)) {
                console.log( 'Raw', node.value)
                const yamlString = node.value.slice(FRONTMATTER_OPEN.length, node.value.length - FRONTMATTER_CLOSE.length).trim()
                try {
                    node.data = yaml.load(yamlString, 'utf8')
                } catch(err) {
                    node.data = {error: err.toString()}
                }
               console.log( 'Parsed', yamlString)
               matters.push(node.data)
            }
        })
        file.data.frontmatter = matters.reduce( (memo,matter) => Object.assign({}, memo, matter || {}), {})
    }
}


•••

### Sections

Sections are automatically created from the nested structure of Headings.

•••md
# Headline (root section)
## Subtitle (child section)
•••

They can be collapse/folded (tbd)

•••md
# >Headline (collapsed)
•••

*Implementation*

•••js !collapse < sections.js
import heading from "mdast-util-heading-range";
import visit from "unist-util-visit";
import flatMap from "unist-util-flatmap";
import { getConsoleForNamespace } from '../utils/console'
import { Identity } from "../utils/functions";

const console = getConsoleForNamespace('sections', {disabled: true})

const firstChild = (node,type) => node.children 
            && node.children[0]
            && node.children[0].type === type

const createCell = (node,nodes) => {
     const pos = node.position
     // pos.start.offset = pos.start.offset - pos.start.column
     // pos.start.column = 0
     return {
          type: "cell",
          position: pos,
          data: {
            hName: "cell",
            hProperties: {
              class: "cell",
            },
          },
          children: nodes || [node],
        }
}

const createSection = (node,nodes) => {
  if (!nodes) node.children = cellsFromNodes(node.children)
  return {
        type: "section",
        data: {
          hName: "section",
        },
        position: node.position,
        children: nodes || [node],
      }
}

const cellsFromNodes = (nodes, {addSectionDataToFirstCell}={}) => {

  const cells = [];
  let newCell = null;

  nodes.map((current, index) => {
    const node = current;
    console.log("[Sections] child: ", index, node.type);

    if (node.type === "section") {
      newCell = null;
      cells.push(node);

    } else if (false && node.type === "list" && node.spread) {
      newCell = null;
      let listSection = createSection(node)
      cells.push(listSection);

    } else if (false && node.type === "listItem" && node.spread) {
      newCell = null;
      let listItem = node
      if (firstChild(listItem, 'section')) {
        console.log("[Sections] ListItem with section: ", node.type);
        listItem.children = listItem.children.map( section => {
          section.children = cellsFromNodes(section.children)
        })
      } else {
        listItem.children = [createSection(node, node.children)]
      }
      
      cells.push(listItem);

    } else if (node.type === "code") {
      const next = nodes[index+1]
      const attached = node => node && node.data && node.data.meta && node.data.meta.attached
      const nextIsAttached = attached(next)
                            
      let singleCell = createCell(node)
      if (nextIsAttached) {
          newCell = singleCell
         
      } else if (newCell && attached(node)) {
          newCell.children.push(node)
          if (node.position) newCell.position.end = node.position.end;
          cells.push(newCell)
          newCell = null

      } else {
          newCell = null
          cells.push(singleCell);
      }
     
     
      
    } else if (newCell) {
      newCell.children.push(node);
      if (node.position) newCell.position.end = node.position.end;

    } else {
      newCell = createCell(node)
      if(addSectionDataToFirstCell) newCell.data.section = addSectionDataToFirstCell
      cells.push(newCell);
    }
  });
  return cells;

}

const wrapSection = (options) => (start, nodes, end) => {
  console.log(
    "[Sections] Wrapping:",
    start && start.data.id,
    nodes && nodes.length,
    end && end.type
  );

  nodes = [start, ...nodes]

  // log("[Section] nodes:", nodes)

  const cells = cellsFromNodes(nodes)

  return [
    {
      type: "section",
      data: {
        id: start.data.id,
        hName: "section",
        hProperties: {
          name: start.data.id,
        },
      },
      position: {
        start: start.position.start,
        end: end ? end.position.end : nodes[nodes.length - 1].position.end,
      },
      children: [
        // Mark that heading as having been mutated,
        // otherwise we'd be processing the same header
        // over and over (infinite loop)
        ...cells,
      ],
    },
  ];
};

const transform = (options) => (node, index, parent) => {
  console.log("[Sections] Visiting", node.data.id)
  return heading(
    parent,
    (_, node2) => node.data.id === node2.data.id,
    wrapSection(options)
  )
}

export const groupIntoSections = (options = {}) => (...args) => (tree) => {
  console.log("[Sections] Init");
  visit(tree, "heading", transform(options), true);
}

export const sections = (...args) => (tree) => {
  console.log('[Sections II] Init.', args, tree.type, tree.children.length)
  let headings = 0
  const newSection = (children) => {
    const first = children[0]
    const last = children[ children.length - 1]
    const depth = first.depth || 0
    first.processed = true
    return {
      type: 'section',
      data: {
        name: first.data.id,
        hName: 'section',
        hProperties: {
          depth: depth
        }
      },
      depth: depth,
      children: children,
      position: {
        start: first.position.start,
        end: last.position.end
      }
    }
  }

  visit(tree, 'heading', (node, index, parent) => {
    if (node.processed) {
      console.log(`[Sections II] Ignoring already processed node ${node.data.id}`)
    } else if (parent.type === 'root') {
      console.log(`[Sections II] heading "${node.data.id}" ${headings}, depth: ${node.depth}`)
      const section = parent.children[index] = newSection([node])
      const children = parent.children
      
      for (let i = index + 1; i < children.length; i++) {
        if (!children[i] || children[i].processed) {
          console.log('Skipping removed', children[i])
          break
        }
        const nextNode = children[i]
        if ((nextNode.type === 'heading' || nextNode.type === 'section') && nextNode.depth <= node.depth) {
          console.log(`[Sections II] ended "${node.data.id}" due to "${nextNode.data.id || nextNode.data.name}"`, nextNode.type, nextNode.depth)
          console.log(`[Sections II] contains: "${node.data.id}"`, section.children.map( n => n.type).join(','))
          break;
        }
        console.log(`[Sections II] child index: ${i}, type: ${nextNode.type} depth: ${nextNode.depth} id: ${nextNode.data && (nextNode.data.id || nextNode.data.name)}`)
        section.children.push(nextNode)
        if (nextNode.position) section.position.end = nextNode.position.end
        delete parent.children[i]
      }
      headings++
      node = section 
      node.children = cellsFromNodes(node.children, {addSectionDataToFirstCell: { id: section.data.id, position: section.position}})
    } else {
      console.log('[Sections II] WARN: Header parent not root', node.data.id)
    }
  }, true)

  tree.children = tree.children.filter(Identity)

  console.log("Headings: ", headings)
}


const cells = (...args) => (tree) => {
  visit( tree, cells )
}


export const ungroupSections = (options = {}) => (...args) => (tree) => {
  console.log("[UnSection] Init", options)
  tree = flatMap(tree, (node) => {
    if (node.type === "cell") {
      return node.children
    } else if (node.type === "section") {
      return node.children
    } else {
      return [node]
    }
  })
  return tree
}

•••

### Cells

*Currently implemented as part of **Sections**, see above.*

### Codeblocks

*Implementation*

•••js !collapse < codeblocks.js
import visit from 'unist-util-visit'
import { getConsoleForNamespace } from '../utils/console'

const console = getConsoleForNamespace('codeblocks')

const LSP = '__.litsp__'
const NONESCAPEDSPACES_REGEX = /([^\\])\s/g
const LANG = 'lang'
const ATTR = 'attribute'
const TAG = 'tag'
const DIREC = 'directive'
const FILENAME = 'filename'
const URI = 'uri'
const UNKNOWN = 'unknown'

const isListType = t => [TAG,DIREC,UNKNOWN].indexOf(t) >= 0

export default function (...args) {
    return (tree) => visit( tree, 'code', transform )
}

function transform (node, index, parent) {  
    console.log( '[CodeBlocks] Visiting: ', node.lang, node.meta)
    const litMeta = parseMeta(node)
    
    node.data = {
        ...node.data,
        meta: litMeta,
        hProperties: {
            className: litMeta && litMeta.tags ? litMeta.tags.map( t => `tag-${t}`).join(' ') : '',
            meta: litMeta,
        }
    }
    return node
}


function parseMeta (node) {
    const raw = `${node.lang || ''} ${node.meta || ''}`.trim()
    console.log(`[CodeBlocks] lang: "${node.lang}" meta: "${node.meta}", raw: "${raw}"`)

    const isOutput = raw.indexOf('>') === 0
    const hasOutput = node.meta && node.meta.indexOf('>') >= 0
    let hasSource = node.meta && node.meta.indexOf('<') >= 0

    let input = raw
    let _, output, source
    let fromSource;

    if (isOutput) {
        [_, input] = raw.split('>').map( x => x.trim() )
    } else {
      if (hasOutput) {
        [input, output] = raw.split('>').map( x => x.trim() )
      }

      if (hasSource) {
        [input,source] = input.split('<').map( x => x.trim() )
        source = getSource(source)
      }
    }

    const meta = input
        .replace(NONESCAPEDSPACES_REGEX, "$1" + LSP)
        .split(LSP)
        .map(ident)
        .reduce(reduceParts, {})
    
    meta.isOutput = isOutput
    meta.output = output
    meta.hasOutput = !!output
    meta.hasSource = !!source
    meta.source = source
    meta.raw = raw
    if (source) meta.fromSource = source.filename || source.uri

    return meta
}

function getSource(source) {
    if (source) {
        return parseMeta({ lang: 'txt', meta: source })
    }
}

function isUri(str) {
  return str.startsWith('http') || str.startsWith('//')
}

function ident (x, i) {
    let type, value = x
    if (i === 0) {
      type = LANG
    }
    else if(x && x[0]) {
      if (x[0] === "#") {
        type = TAG
        value = x.slice(1)
      }
      else if (x[0] === "!") {
        type = DIREC
        value = x.slice(1)
      }
      else if (x.indexOf("=") > 0) {
        type = ATTR
        value = x.split("=")
        value = {
          type: value[0],
          value: value[1]
        }
      }
      else if(i===1) {

        if (isUri(x)) type = URI
        else type = FILENAME
      }
      else if (!type) type = UNKNOWN
    }
    return {type, value}
  }
  
  function reduceParts(memo,item, i) {
    memo.attrs = memo.attrs || {}

    if (item.type === ATTR){
        memo.attrs[item.value.type] = item.value.value
        item = item.value
    }

    if (isListType(item.type)) {
        const collective = `${item.type}s`
        if(memo[collective]) {
             memo[collective]
             .push(item.value)
        } else {
            memo[collective] = [item.value]
        }
        if (item.type === DIREC) {
            // memo.attrs[item.value] = true
        }
    } else {
        memo[item.type] = item.value
    }
    
    return memo
}
  


•••

### Markdown blocks

*Implementation*

•••js !collapse < mdblocks.js

import visit from 'unist-util-visit'
import {getConsoleForNamespace} from '../utils/console'

const console = getConsoleForNamespace('mdblocks')

export const mdblocks = function ({baseProcessor}) {
    return async (tree, file) => {
        file.data = file.data || {}
        file.data.__mdcodeblocks = 0
        const promises = [];
        visit(tree, 'code', (node,index,parent) => {
            if (!node.data || !node.data.meta || node.data.meta.lang !== 'md') return;

            const idx = file.data.__mdcodeblocks++
            // instead of await (why?)
            const p = new Promise(async resolve => {
                // console.log(idx + "Node: ", node)
                const p = baseProcessor()
                const parsed = await p.parse( node.value )
                const ast = await p.run(parsed)
                //  console.log(idx + " AST: ", ast)
                node.children = ast.children
                resolve()
            });
           
            promises.push(p)
        });
        await Promise.all(promises);
        return null
    }
}
•••

### Links

*Implementation*

•••js !collapse < links.js
import path from 'path'
import visit from 'unist-util-visit'
import { getConsoleForNamespace } from '../utils/console'

const console = getConsoleForNamespace('links', {disabled: true})

export const resolveLinks = (options = { litroot: '', filepath: ''}) => (...args) => tree => {
    console.log('[Links] Init', options)
    return visit(tree, isLink, transform(options))
}

const isLink = (node) => ['link', 'wikiLink'].indexOf(node.type) >= 0

const transform = options => (node, index, parent) => {
    return decorateLinkNode(node, options.litroot, options.filepath)
}

export const wikiLinkOptions = files => ({
     pageResolver: (name) => [
       name.replace(/[^\w\s/-]+/g,'')
           .trim()
           .replace(/\s+/g, '_')
           .toLowerCase()
     ],
})
// ({ 
//     permalinks: files,
//     pageResolver: nameToPermalinks,
//     hrefTemplate: (permalink) => `${permalink}?file=${permalink}`
// })

const linkToUrl = (link, root) => {
    if (link.type === 'wikiLink') {
        const [base,frag] = link.data.permalink.split("#")
        return `${root}${base}.lit${frag ? ('#' + frag) : ''}`
    } else {
        return link.url
    }
}

export const decorateLinkNode = (link, root = '', filepath = '') => {
    // console.log(link)
    const wikilink = link.type === 'wikiLink'
    const url = linkToUrl(link, root)

    // console.log(`[Links] resolving (${link.type}) [${url}] '${root}', "${filepath}"`)
    const isAbsolute = /(https?\:)?\/\//.test(url)
    const isFragment = /^(\?|#).*/.test(url)
    const isRelative = url && !isAbsolute && !isFragment

    let canonical = url
    let href = url
    let [base,frag] = url.split(/(\?|#)/)

    if (isRelative) {
        const abs = path.resolve(root, path.dirname(filepath), url)
        canonical = path.relative(path.resolve(root), abs)
        href = url.replace(/\.(md|lit)/i, '.html')
    }

    link.type = 'link'
    link.url = href
    link.title = link.title || link.value
    link.data = {
        isAbsolute,
        isFragment,
        isRelative,
        canonical,
        wikilink,
    }

    if (wikilink) {
        [base,frag] = link.url.split("#")
        link.url = base + '?file=' + canonical + (frag ? `#${frag}` : '')
        link.children = [{position: link.position, type: 'text', value: link.value }]
    }

    link.data.hProperties = {
        wikilink,
        data: {
             base, 
             frag,
             isAbsolute,
             isFragment,
             isRelative,
             canonical,
             wikilink,
        }
    }
    
    delete link.value

    return link
}

export const nameToPermalinks = (name) => {
    const full = name.replace(/ /g, '_').toLowerCase()
    const tail = path.basename(full)

    return ['.lit', 'md'].flatMap( ext => [full + ext, tail + ext])
    return [full+'.lit', full+'.md', tail+'.lit', tail+'.md']
}
export const nodeMappings = (files) => {
    const mappings = {}
    files.forEach( (filepath) => {

    })
    return mappings;
}

•••

## AST to String

•••js
const {toMarkdown, ungroupSections}
      = lit.parser.utils
const unGroup = ungroupSections()()
const tree = unGroup(lit.ast)
const md = toMarkdown(tree)
return md
•••

•••>txt attached=true updated=1621249764049
[ { start: { line: 77, column: 1, offset: 1363 },
    end: { line: 79, column: 4, offset: 1461 } } ]
•••

```








