# Fuzzy text search

Related

- [[testing/compact_manifest]]

## Fuse.js

https://fusejs.io/

https://dev.to/noclat/using-fuse-js-with-react-to-build-an-advanced-search-with-highlighting-4b93

```js !collapse #intro
return (async (fn) => {
  const { default: Fuse } = await import(
    "https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.esm.js"
  );
  const manifest = await fetch("/manifest.json").then((res) => res.json());
  const fuse = new Fuse(manifest.nodes, {
    includeScore: true,
    keys: ["title", "id"],
  });

  // 3. Now search!
  return fuse.search("../../..",{limit:5});
})();

```
```js !plugin !collapse type=repl of=search
export const repl = async (src, meta) => {
  const t = Date.now();

  const { default: Fuse } = await import(
    "https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.esm.js"
  );
  // const manifest = await fetch("/manifest.json").then((res) => res.json());
  // Recursively builds JSX output adding `<mark>` tags around matches
  const highlight = (value, indices = [], i = 1) => {
    const pair = indices[indices.length - i];
    return !pair
      ? value
      : `${highlight(
          value.substring(0, pair[0]),
          indices,
          i + 1
        )}***${value.substring(pair[0], pair[1] + 1)}***${value.substring(
          pair[1] + 1
        )}`;
  };
  const fullLocal = await (async (fn) => {
    const path = lit.utils.path;
    const all = [];
    const visit = async (root) => {
      try {
        const list = await lit.fs.readdir(root);
        return Promise.all(
          list.map(async (key) => {
            const pathname = path.join(root, key);
            const stat = await lit.fs.stat(pathname);
            let contents;
            if (key === ".git" || !key) {
            } else if (stat.type === "dir") await visit(pathname);
            else if (pathname.endsWith(".lit"))
              contents = await lit.fs.readFile(pathname, {
                encoding: "utf8",
                localOnly: true,
              }); //.slice(0,10);
            const item = { pathname, type: stat.type, contents };
            all.push(item);
            return item;
          })
        );
      } catch (err) {
        alert(err.message);
      }
    };

    await visit("/");
    return all;
  })();

  // return fullLocal

  const fuse = new Fuse(fullLocal, {
    ignoreLocation: true,
    includeScore: true,
    includeMatches: true,
    ignoreFieldNorm: true,
    minMatchCharLength: 4,
    keys: ["pathname", "contents"],
  });

  // 3. Now search!
  const query = src.trim();
  const msg = `Results for search "**${query}**". In **${
    (Date.now() - t) / 1000
  }** seconds.\n\n`;

  return (
    msg +
    fuse
      .search(query, { limit: 10 })
      //.map(x=>x.matches.map(x=>x.indices))
      .map((x) => [x.score, x.item.pathname, x.refIndex, x.matches])
      .map(
        ([score, pathname, index, matches]) => `1. [${pathname}](${pathname})`
      )
      .join("\n")
  );
};

```
```js search.jsx !plugin !collapse type=viewer Babel=true of=search2
import Fuse from "https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.esm.js";
export const viewer = ({ node, React }) => {

  const {useEffect,useState} = React
  const [msg, setMsg] = useState('Searching...')
  // const manifest = await fetch("/manifest.json").then((res) => res.json());

  // Recursively builds JSX output adding `<mark>` tags around matches
  const highlight = (value, indices = [], i = 1) => {
    const pair = indices[indices.length - i];
    return !pair ? (
      value
    ) : (
      <>
        {highlight(value.substring(0, pair[0]), indices, i + 1)}
        <mark>{value.substring(pair[0], pair[1] + 1)}</mark>
        {value.substring(pair[1] + 1)}
      </>
    );
  };

  const fullLocal = async (fn) => {
    const path = lit.utils.path;
    const all = [];
    const visit = async (root) => {
      try {
        const list = await lit.fs.readdir(root);
        return Promise.all(
          list.map(async (key) => {
            const pathname = path.join(root, key);
            const stat = await lit.fs.stat(pathname);
            let contents;
            if (key === ".git" || !key) {
            } else if (stat.type === "dir") await visit(pathname);
            else if (pathname.endsWith(".lit"))
              contents = await lit.fs.readFile(pathname, {
                encoding: "utf8",
                localOnly: true,
              }); //.slice(0,10);
            const item = { pathname, type: stat.type, contents };
            all.push(item);
            return item;
          })
        );
      } catch (err) {
        alert(err.message);
      }
    };

    await visit("/");
    return all;
  };

  // return fullLocal

  useEffect(async fn => {
     const t = Date.now();
const fuse = new Fuse(await fullLocal(), {
    ignoreLocation: true,
    includeScore: true,
    includeMatches: true,
    ignoreFieldNorm: true,
    minMatchCharLength: 4,
    keys: ["pathname", "contents"],
  });

  // 3. Now search!
  const query = node.data.value.trim();

  return (
    <div>
      <span>{msg}</span>
    </div>
  );
};

```



```text repl=search > md
test
```
```>md attached=true updated=1621894219089
Results for search "**test**". In **0.077** seconds.

1. [/testing/lightningfs.lit](/testing/lightningfs.lit) 

    > /***test***ing/lightningfs.lit ... # Lightning FS

https://github.com/isomorphic-git/lightning-fs

## Table of Contents

## Bugs 🐜

- [x] wikiLinks and 404 behaviour results in incorrect/dangling lfs due to incorrect baseUrl.

## Tour of the API
•••js
return lit.fs.readdir('/***test***ing/log')
•••

•••js > json !collapse
return lit.lfs.promises.writeFile('/***test***ing/data.json', "{}", {encoding: 'utf8'})
•••
•••>json !collapse attached=true updated=1621193177415
null
•••

•••js > json !collapse
return lit.fs.readFile('/doesntexist.json')
•••
•••js > json !collapse
return lit.fs.readStat('/manifest.json')
•••

•••js > json !collapse
return lit.fs
          .readStat('/manifest.json')
          .then(stat => [!!stat.local.value, !!stat.remote.value])
•••
•••>json !collapse attached=true updated=1619878321018
[ true, false ]
•••
•••js > json !collapse
return lit.fs
          .stat('/notfound')
          .catch(s => "404 Not Found")
•••
•••>json !collapse attached=true updated=1621124612430
404 Not Found
•••
•••js > json !collapse
return lit.fs
          .stat('/index.lit')
          .then(stat => stat)
•••
•••>json !collapse attached=true updated=1619878403441
{ type: 'file',
  mode: 438,
  size: 4589,
  ino: 6,
  mtimeMs: 1619686223652,
  ctimeMs: 1619686223652,
  uid: 1,
  gid: 1,
  dev: 1 }
•••
•••js > diff !collapse
// https://github.com/kpdecker/jsdiff
const {root,src} = lit.location
const {join} = lit.utils.path
const filename = join(root,src)

const withStats = async stats => {
  const cp = lit.utils.diff.createPatch
  // const f = 
  const local = stats.local.value
  const remote = stats.remote.value
  const patch = cp(filename, local, remote)
  console.log(patch.split('\n').map(l=>'    '+l).join('\n'))
  return "logged patch"
}

const stats = lit.fs.readStat(filename, {encoding: 'utf8'})
return stats.then(withStats)
•••
•••>diff !collapse attached=true updated=1620338765234
    Index: /***test***ing/lightningfs.lit
    ===================================================================
    --- /***test***ing/lightningfs.lit
    +++ /***test***ing/lightningfs.lit
    @@ -1697,13 +1697,57 @@
     
     const stats = lit.fs.readStat(filename, {encoding: 'utf8'})
     return stats.then(withStats)
     ```
    -```>diff !collapse attached=true updated=1620338750310
    +```>diff !collapse attached=true updated=1620338108145
         Index: /***test***ing/lightningfs.lit
         ===================================================================
         --- /***test***ing/lightningfs.lit
         +++ /***test***ing/lightningfs.lit
    +    @@ -1680,34 +1680,31 @@
    +       dev: 1 }
    +     ```
    +     ```js > diff !collapse
    +     // https://github.com/kpdecker/jsdiff
    +    -const {root,src} = lit.location
    +    -const {join} = lit.utils.path
    +    -const filename = join(root,src)
    +    +const filename = '/index.lit'
    +     
    +     const withStats = async stats => {
    +       const cp = lit.utils.diff.createPatch
    +    -  // const f = 
    +    +  // const f = lit.location.src
    +       const local = stats.local.value
    +       const remote = stats.remote.value
    +       const patch = cp(filename, local, remote)
    +    -  console.log(patch.split('\n').map(l=>'    '+l).join('\n'))
    +    +  // console.log(patch)
    +       return "logged patch"
    +     }
    +     
    +     const stats = lit.fs.readStat(filename, {encoding: 'utf8'})
    +     return stats.then(withStats)
    +     ```
    +    -```>diff !collapse attached=true updated=1620337567383
    +    -Index: /***test***ing/lightningfs.lit
    +    +```>text !collapse attached=true updated=1620336678219
    +    +Index: /index.lit
    +     ===================================================================
    +    ---- /***test***ing/lightningfs.lit
    +    -+++ /***test***ing/lightningfs.lit
    +    -@@ -1680,26 +1680,24 @@
    +    -   dev: 1 }
    +    - ```
    +    +--- /index.lit
    +    ++++ /index.lit
    +     
    +    +logged patch
    +    +```
    +     
    +     
    +     ```>fs ls=/
    +     
         
     logged patch
     ```
     
    
logged patch
•••
•••js #delete !localonly
const path = "/throwaway/***test***.txt"
console.log(ast)
return lit.fs.writeFile(path, "content", {
  encoding: 'utf8',
  localOnly: true
})
•••
•••>txt attached=true updated=1621257066210
{ type: 'element',
  tagName: 'cell',
  properties: { class: 'cell' },
  children: 
   [ { type: 'element',
       tagName: 'pre',
       properties: {},
       children: [Object],
       position: [Object] },
     { type: 'element',
       tagName: 'pre',
       properties: {},
       children: [Object],
       position: [Object] } ],
  position: 
   { start: { line: 155, column: 1, offset: 51462 },
     end: { line: 177, column: 4, offset: 52007 } } }
undefined
•••





## Plugins 

### `fs` plugin

•••js
return lit.utils.momento
•••
•••>txt attached=true updated=1621257612846
{ MsToRelative: [G***ette***r], Da***tesT***oRelativeDelta: [G***ette***r] }
•••


•••jsx fsviewer.jsx babel=true !plugin of=fs !collapse
export const viewer = ({node, React}) => {
  const {u***seSt***ate, useEffect} = React
  const {join,extname} = lit.utils.path
  const [src, ***setS***rc] = u***seSt***ate(node?.data?.value?.trim())
  const meta = node?.properties?.meta || {}

  const styles = {
    dir: {fontWeight: "bold"},
    '.lit': {color: 'blue'},
  }
  const getType = s => {
    const [filepath,stat] = s
    if (stat.type === 'file') {
      return extname(filepath)
    }
    return stat.type
  }

  const Stat = (props) => {
    const stat = props?.stat || {}
    if (stat.message) return <div>{stat.message}</div>
    return <div>
      <div style={{marginBottom: '0.4em'}}>Type: <span>{stat.type}</span> mtime: <span>{lit.utils.momento.MsToRelative(stat.mtimeMs - Date.now())}</span> Size: <span>{(props.size / 1024).toFixed(2)} KB</span></div>
      
      {stat.contents && stat.contents.map( l => {
      const name = l[0]
      const path = join(props.src,name)
      const type = getType(l)
      const style = styles[type] || null
      return <div><span onClick={ev=> props.select(path)} style={style}>{name}</span></div>
     })}
    </div>
  }

  const [content, setContent] = u***seSt***ate(<span>loading...</span>)
  const [stat, ***setSt***at] = u***seSt***ate(undefined)
  const [size, ***setS***ize] = u***seSt***ate(null)

  useEffect(async fn => {
    let stat, size
    try {
      stat = await lit.fs.stat(src)
      size = await lit.fs.du(src)
      if (stat.type === 'dir') {
          const list = await lit.fs.readdir(src)
          const withStats = list.map( async l => [l,await lit.fs.stat(join(src,l))])
          stat.contents = await Promise.all(withStats)
      }
      ***setSt***at(stat)
      ***setS***ize(size)
    } catch(err) {
      ***setSt***at(err)
      ***setS***ize(null)
    }
  }, [src])

  const bigger = {fontSize: '1em', width: '100%'}
  return <div style={bigger}>
     <input style={bigger} value={src} onChange={ev=>***setS***rc(ev.target.value)}/>
     <div style={{fontFamily: 'monospace', marginBottom: '0.4em'}}>
     <Stat src={src} stat={stat} size={size} select={***setS***rc}/>
     {!stat && content}
     </div>
     <button disabled={src === '/'} onClick={ev=>  ***setS***rc(src.split('/').slice(0,-1).join('/') || '/')}>Back</button>
     {stat && <button disabled>R***eset***</button>}
     {stat && <button onClick={ev=> confirm("Are you sure you want to delete " + src) && lit.fs.unlink(src)}>Delete</button>}
     {stat && <button disabled>Diff</button>}
    </div>
}
•••

•••>fs
/
•••

### Finder (local fs)

•••js !collapse > json
const path = lit.utils.path;
const visit = async (root) => {
  const list = await lit.fs.readdir(root);
  return Promise.all(
    list.map(async (key) => {
      const pathname = path.join(root, key);
      const stat = await lit.fs.stat(pathname);
      let contents;
      if (key === ".git" || !key) {
        return { key, root,pathname, type: stat.type };
      } else if (stat.type === "dir") {
        // alert("Traversing " + pathname);
        contents = await visit(pathname);
      } else
        contents =
          (
            await lit.fs.readFile(pathname, {
              encoding: "utf8",
              localOnly: true,
            })
          ).slice(0, 10) + "...";
      return { pathname, type: stat.type, contents };
    })
  );
};

return (async (fn) => {
  lit.fs.writeFile(
    "/***test***ing/full.json",
    JSON.stringify(await visit("/"), null, 2)
  );
})();

•••
•••>json attached=true updated=1621861533762
undefined
•••

•••json2 !inline < full.json


•••


### Finder (from manifest)


•••js !plugin type=viewer !collapse of=search
const sortBy = (keys) => (a, b) => {
  for (const key of keys) {
    if (a[key] !== b[key]) break;
    else return a[key] > b[key] ? 1 : -1;
  }
};

const itemBuilder = (React) => (item) => {
  const rc = React.createElement;
  return rc(
    "li",
    { className: "item" },
    rc(
      "a",
      { href: lit.href || lit.location.root + item.id },
      item.title || item.id
    )
  );
};

export const viewer = ({ node, React }) => {
  const rc = React.createElement;
  const { u***seSt***ate, useEffect } = React;
  const meta = node.properties && node.properties.meta;
  const [src, ***setS***rc] = u***seSt***ate(meta.search || node.data.value.trim());
  const [content, setContent] = u***seSt***ate("Loading...");
  const item = itemBuilder(React);

  useEffect(async () => {
    const resp = await fetch("/manifest.json");
    const json = await resp.json();
    let regex;
    try {
      regex = new RegExp(src, "i");
    } catch (err) {}
    const res = json.nodes
      .map((x) => x)
      .filter((x) => {
        return (
          x.id.indexOf(src) >= 0 ||
          (regex && regex.***test***(x.id)) ||
          (x.title &&
            (x.title.indexOf(src) >= 0 || (regex && regex.***test***(x.title))))
        );
      })
      .sort()
      .map((x) => item(x));
    //.join("\n")
    setContent(rc("ol", null, res));
  }, [src]);

  return rc(
    "div",
    {
      className: "custom-react-view",
    },
    [
      rc("input", {
        style: { width: "100%", fontSize: "1.2em" },
        value: src,
        onChange: (e) => ***setS***rc(e.target.value),
      }),
      content,
    ]
  );
};

•••
•••>search
G.*hUb
•••
## Sync `local|remote|origin`


•••js #sync !collapse
// fetch all remote files and store
// locally if they don't already exist 


return (async fn => {
  const t = Date.now()
  const p = lit.utils.path
  const writePLocal = async (...args) => {
    
  }

  const m = await fetch('/manifest.json')
                  .then(res => res.json())
                  .catch(e=>({nodes:[]}))

  const duds = []
  const synced = []
  const errors = []
  const res = await Promise.all(m.nodes.map( async n => {
    try {
    n.stats = await lit.fs.readStat(n.id)
      .then(x=>x)
      .catch(err=>{
          duds.push(n.id)
          return {local: {}, remote: {}}
      })

    if (!n.stats.local.stat && n.stats.remote.stat) {
        await lit.fs.writeFile(n.id, n.stats.remote.value, {localOnly: true, encoding: 'utf8'})
        synced.push(n)
    }
    
    return n
    } catch(err) {errors.push(n.id + " : " + err.message)} 
  } ))
  console.log(`Synced ${synced.length}/${m.nodes.length} files in ${(Date.now() - t)/1000} seconds. Duds: ${duds.length} Errors: ${errors.length}`)
  return {duds, errors}
})()

•••
•••>txt attached=true updated=1621892351482
Synced 0/189 files in 0.407 seconds. Duds: 30 Errors: 2
{ duds: 
   [ 'transfomers.lit',
     'custom-module.mjs',
     'log/checkforinput.js',
     'agora.lit',
     'components.lit',
     'rk.jsx',
     'viewers.lit',
     'litconfig.lit',
     '***test***ing/g***etse***rviceworker--sw',
     'fsviewer.jsx',
     'worker2.js',
     'wikilinks.lit',
     '.github/workflows/generate.yaml',
     'renderer/file.txt',
     'utils/urifragments.lit',
     '/***test***ing/log/2021-w22.lit',
     'worker.js',
     'meta/.github/workflows/npm-publish.yaml',
     'meta/files_and_links.lit',
     'viewers/meta.js',
     'utils/fs.lit',
     'distributed_knowledge_graph.lit',
     'markdown.lit',
     'runkit-repl-endpoint.js',
     'experimental_social_network.lit',
     'log/today.js',
     'filename',
     'remark.lit',
     'gitworker.js',
     'unified.lit' ],
  errors: 
   [ '../scratch_pad.lit#viewers : Unable to normalize path - traverses above root directory',
     '../serviceworker.js : Unable to normalize path - traverses above root directory' ] }
•••
•••>txt  updated=1621257192205
Synced 90/139 files in 0.616 seconds. Duds: 30 Errors: 7
{ duds: 
   [ 'remark.lit',
     'viewers.lit',
     '.github/workflows/generate.yaml',
     'components.lit',
     'utils/urifragments.lit',
     'articles/ideas.lit',
     'executing_code_cells.lit',
     './runkit-repl-endpoint.js',
     'transfomers.lit',
     'fsviewer.jsx',
     'viewers/meta.js',
     'filename',
     'worker.js',
     'worker2.js',
     '../../../../../***test***ing/log/2021-05.lit',
     'utils/fs.lit',
     '../../../../../***test***ing/log/2021.lit',
     'rk.jsx',
     '../../../../../***test***ing/log/2021-05',
     'wikilinks.lit',
     'unified.lit',
     '***test***ing/g***etse***rviceworker--sw',
     'meta/.github/workflows/npm-publish.yaml',
     'renderer/file.txt',
     'markdown.lit',
     '../../../../../***test***ing/log/year.lit',
     'log/today.js',
     'log/checkforinput.js',
     'litconfig.lit',
     '../../../../../***test***ing/log/2021' ],
  errors: 
   [ '../scratch_pad.lit#viewers : Unable to normalize path - traverses above root directory',
     '../components/components.lit : Unable to normalize path - traverses above root directory',
     '../../../../../meta/***sett***ings.lit#plantuml-viewer--repl : Unable to normalize path - traverses above root directory',
     '../../../../../***test***ing/log/2021-w20.lit : Unable to normalize path - traverses above root directory',
     '../../../../../***test***ing/log/2021-05-12.lit : Unable to normalize path - traverses above root directory',
     '../utils/git-commit-all.js : Unable to normalize path - traverses above root directory',
     '../../../../../***test***ing/log/2021-w21.lit : Unable to normalize path - traverses above root directory' ] }
•••




## Emergency wipe ⚠️

•••>md !warn
Clicking on the following link will prompt you to confirm you want to wipe the local file system!
•••

[WIPE ⚠️](?__lfs_wipe=true)


1. [/testing/isomorphic_git.lit](/testing/isomorphic_git.lit) 

    > /***test***ing/isomorphic_git.lit ... # Isomorphic Git


Since `.lit` already uses [[***test***ing/LightningFS]] for the local filesystem we can easily use https://isomorphic-git.org/docs/en/quickstart to manage versioning...

## Table of Contents

## Initial plan

The initial plan is to just auto commit on all actions, enabling "infinite" undo.

Thereafter that may remain the default but ideally an ergonomic version of the raw git api can be exposed for more advanced users.

*Implementation*





•••js ../utils/git-commit-all.js !plugin type=fn id=git-commit-all !collapse
// initially, because it's on every change 
// a commit will mostly be for a single
// file at a time the immediate exception 
// being when a file with output files 
// is edited, in which case the commit 
// includes those files.

export const fn = async () => {
  const now = (new Date()).toISOString()

  const fs = lit.lfs 
  const dir = lit.location.root
  const git = lit.git
  const FILE = 0, WORKDIR = 2, STAGE = 3

  const unstaged = row => {
    return row[WORKDIR] !== row[STAGE]
  }

  // get/list unstaged files
  const status = await git.statusMatrix({ fs,dir})
  const files = status
                .filter( unstaged )
                .map(row => row[FILE])

  // stage everything
  await git.add({fs, dir, filepath: '.'})

  // message 
  const message = `Commit ${lit.location.src}

at ${now} includes the following ${files.length} files:
${files.map(f=> "- " + f).join('\n')}`

  // return message

  // commit
  const sha = await git.commit({fs, dir,
    message,
    author: {
      name: 'dotlitbot',
      email: 'bot@dotlit.org'
    }
  })
  return `Committed ${sha.slice(0,6)} 
${message}`
}
•••
•••js !plugin id=git type=menu !collapse
export const menu = (ctx, {React, Menu}) => {
  const rc = React.createElement
  const commit = lit.file.data.plugins.fn['git-commit-all']
  const onClick = async ev => alert(await commit())
  return rc( Menu, {
    title:"Git",
    disabled: false,
  }, [rc('span', {onClick}, 'Commit All')])
}
•••
•••txt updated=1619425559711
Committed d738da 
Auto commit ***test***ing/isomorphic_git.lit

at: 2021-04-26T08:25:54.893Z
includes the following 2 files:
- ***test***ing/isomorphic_git.lit
- utils/git-commit-all.js
•••
## Investigating API


•••js
return lit.fs
       .readFile('/.git/HEAD', {
          encoding: 'utf8'
        })
•••
•••>txt attached=true updated=1621327741152
ref: refs/heads/master

•••
•••js
return (async () => {
  return await lit.git.init({
    fs: lit.lfs, 
    dir: lit.location.root
  })
})()
•••
•••>txt attached=true updated=1621327753489
undefined
•••
### Status

•••js
return (async () => {
  return lit.location.src + " : " + await lit.git.status({
    fs: lit.lfs, 
    dir: lit.location.root, 
    filepath: '.' 
  })
})()
•••
•••>txt attached=true updated=1621335274603
***test***ing/isomorphic_git.lit : *added
•••
•••js
return (async () => {
  return await lit.git.statusMatrix({
    fs: lit.lfs, 
    dir: lit.location.root, 
    filepaths: ['***test***ing/']
  })
})()
•••
•••>txt attached=true updated=1621123831529
[ [ '<', 1, 0, 1 ],
  [ 'articles/ideas_for.lit', 1, 1, 1 ],
  [ 'execute_code_cells.lit', 1, 1, 1 ],
  [ 'index.lit', 1, 1, 1 ],
  [ 'log/2021-05-11.lit', 1, 1, 1 ],
  [ 'meta/***sett***ings.lit', 1, 1, 1 ],
  [ 'parser/parser.lit', 1, 1, 1 ],
  [ 'plugin_system.lit', 1, 1, 1 ],
  [ 'renderer/renderer.lit', 1, 1, 1 ],
  [ 'renderer/viewers', 1, 0, 1 ],
  [ 'repls.lit', 1, 1, 1 ],
  [ 'scratch_pad.lit', 1, 1, 1 ],
  [ '***test***ing/input_buffer.lit', 1, 1, 1 ],
  [ '***test***ing/isomorphic_git.lit', 1, 1, 1 ],
  [ '***test***ing/lightningfs.lit', 1, 1, 1 ],
  [ '***test***ing/log/2021-05-09.lit', 1, 1, 1 ],
  [ '***test***ing/log/2021-05-11.lit', 1, 1, 1 ],
  [ '***test***ing/log/2021-05-12.lit', 1, 1, 1 ],
  [ '***test***ing/log/2021-05-13.lit', 1, 1, 1 ],
  [ '***test***ing/log/2021-05-15.lit', 1, 1, 1 ],
  [ '***test***ing/log/2021-w20.lit', 1, 1, 1 ],
  [ '***test***ing/log/checkforinput.js', 1, 1, 1 ],
  [ '***test***ing/log/today.js', 1, 1, 1 ],
  [ '***test***ing/runkit-repl-endpoint.js', 1, 1, 1 ],
  [ '***test***ing/runkit.lit', 1, 1, 1 ],
  [ '***test***ing/serviceworker.lit', 1, 1, 1 ],
  [ 'utils/momento.lit', 1, 1, 1 ] ]
•••



•••js
const fs = lit.lfs 
const dir = lit.location.root
const git = lit.git
const FILE = 0, WORKDIR = 2, STAGE = 3

// list files with unstaged changes
return (async () => {
  const filenames = (await git.statusMatrix({ fs,dir}))
  .filter(row => row[WORKDIR] !== row[STAGE])
  .map(row => row[FILE])
  return filenames
})()
•••
•••>txt attached=true updated=1621123864584
[ '<', 'renderer/viewers', '***test***ing/isomorphic_git.lit' ]
•••
### Add

•••js

const fs = lit.lfs
const dir = lit.location.root

return (async ()=> {
  return await lit.git.add({
    fs,
    dir,
    filepath: '.'
  })
})()
•••
•••>txt attached=true updated=1621335127754
undefined
•••



### Commit

•••js

const fs = lit.lfs
const dir = lit.location.root

return (async ()=> {
const now = (new Date()).toISOString()
let sha = await lit.git.commit({
  fs,
  dir,
  message: `Auto commit (${now})`,
  author: {
    name: 'dotlit',
    email: 'bit@dotlit.org'
  }
})

console.log(sha)

})()
•••
•••>txt attached=true updated=1619388707640
2c1dcf840173cd7c36aa1e5b96bc0922006de579
undefined
•••

### Log

•••js > text !collapse
const indentLines = str => str.split('\n').map( line => `      ${line}`).join('\n')

return (async ()=> {
  let commits = await lit.git.log({
     fs: lit.lfs, 
     dir: lit.location.root, 
     depth: 10
  })
  return "**Log**\n" + commits.map( x => `1. **\`${x.oid.slice(0,6)}\`**

${indentLines(x.commit.message)}`).join('\n')
})()
•••
•••>text !collapse attached=true updated=1620129831107
**Log**
1. **`d738da`**

      Auto commit ***test***ing/isomorphic_git.lit
      
      at: 2021-04-26T08:25:54.893Z
      includes the following 2 files:
      - ***test***ing/isomorphic_git.lit
      - utils/git-commit-all.js
      
1. **`498191`**

      Auto commit ***test***ing/isomorphic_git.lit
      
      at: 2021-04-26T08:16:04.689Z
      includes the following 5 files:
      - 404.lit,- execute_code_cells.lit,- ***test***ing/.gitignore,- ***test***ing/isomorphic_git.lit,- ***test***ing/lightningfs.lit
      
1. **`ef8bee`**

      Auto commit ***test***ing/isomorphic_git.lit
      
      at: 2021-04-25T23:25:46.517Z
      includes the following 1 files:
      - ***test***ing/isomorphic_git.lit
      
1. **`e146ec`**

      Auto commit ***test***ing/isomorphic_git.lit
      
      at: (2021-04-25T23:25:04.262Z)
      includes the following 1 files:
      - ***test***ing/isomorphic_git.lit
      
1. **`ccc6f8`**

      Auto commit ***test***ing/isomorphic_git.lit
      at: (2021-04-25T22:41:55.195Z)
      includes the following tk files...
      
1. **`d6a406`**

      Auto commit (2021-04-25T22:35:27.239Z)
      
1. **`2c1dcf`**

      Auto commit (2021-04-25T22:11:46.433Z)
      
1. **`769349`**

      Auto commit (${now})
      
1. **`74737c`**

      Commit All!!!
      
1. **`a90dc6`**

      Commit All!!!
      
•••

### Diff

•••js
const {git, lfs} = lit
return [git.walk, git.TREE]
•••
•••>txt attached=true updated=1620405199415
[ [Function: walk], [Function: TREE] ]
•••
•••js !collapse
return lit.git
  const commitHash1 = '0c40ed746ebe53cf744d78191d0bbc2941537280'
  const commitHash2 = 'b081f51cd27f54cf58915512006838d4eb67716b'
  const git = lit.git
  return git.walk({
    lit.lfs,
    lit.location.root,
    trees: [git.TREE({ ref: commitHash1 }), git.TREE({ ref: commitHash2 })],
    map: async function(filepath, [A, B]) {
      return filepath
    })
  )}
•••
•••>txt attached=true updated=1620405076140 !error
undefined
•••

## Http client

•••js

return (async fn =>{
  const http = await import('https://unpkg.com/isomorphic-git/http/web/index.js')
  return lit.git.getRemoteInfo({ http: http.default, url: 'https://github.com/isomorphic-git/isomorphic-git' })
})()

•••
•••>txt attached=true updated=1621336307318
undefined
•••

## Web worker

•••>js gitworker.js
/* eslint-env worker */
/* globals LightningFS git MagicPortal GitHttp */
importScripts(
  "https://unpkg.com/@isomorphic-git/lightning-fs",
  "https://unpkg.com/isomorphic-git@beta",
  "https://unpkg.com/isomorphic-git@beta/http/web/index.umd.js",
  "https://unpkg.com/magic-portal"
);

let fs = new LightningFS("fs", { wipe: true });
const portal = new MagicPortal(self);
self.addEventListener("message", ({ data }) => console.log(data));

(async () => {
  let mainThread = await portal.get("mainThread");
  let dir = "/";
  portal.set("workerThread", {
    setDir: async _dir => {
      dir = _dir;
    },
    clone: async args => {
      fs = new LightningFS("fs", { wipe: true });
      try{
      return git.clone({
        ...args,
        fs,
        http: GitHttp,
        dir,
        onProgress(evt) {
          mainThread.progress(evt);
        },
        onMessage(msg) {
          mainThread.print(msg);
        },
        onAuth(url) {
          console.log(url);
          return mainThread.fill(url);
        },
        onAuthFailure({ url, auth }) {
          return mainThread.rejected({ url, auth });
        }
      });
      } catch(err) {
        mainThread.failure({message}=err)
      }
    },
    listBranches: args => git.listBranches({ ...args, fs, dir }),
    listFiles: args => git.listFiles({ ...args, fs, dir }),
    log: args => git.log({ ...args, fs, dir })
  });
})();
•••

•••html #reference !collapse
<div>
  <input
    id="repository"
    type="text"
    style="width: 50em"
    title="Tip: enter a private repo URL to see the credentialManager plugin prompt for a password.",
    value="https://github.com/isomorphic-git/isomorphic-git",
  />
  <button type="button" id="cloneButton">Clone</button>
</div>
<div>
  <progress id="progress" value="0"></progress>
  <span id="progress-txt" style="font-family: monospace;"></span>
</div>
<output id="log" style="white-space: pre; font-family: monospace;"></output>

<script src="https://unpkg.com/magic-portal"></script>
<script>
  // alert("Running")
  const $ = id => document.getElementById(id);

  let worker = new Worker("gitworker.js");
  const portal = new MagicPortal(worker);
  worker.addEventListener("message", ({ data }) => console.log(data));

  const mainThread = {
    async print(message) {
      let text = $("log").textContent;
      if (message.endsWith("\r")) {
        // overwrite last line
        text = text.trim().replace(/.+$/, "");
      }
      text += message + "\n";
      $("log").textContent = text;
    },
    async progress(evt) {
      $("progress-txt").textContent = evt.phase;
      $("progress").value = evt.total ? evt.loaded / evt.total : 0.5;
      return;
    },
    async fill(url) {
      let username = window.prompt("Username:");
      let password = window.prompt("Password:");
      return { username, password };
    },
    async rejected({ url, auth }) {
      window.alert("Authentication rejected");
      return;
    }
  };
  portal.set("mainThread", mainThread, {
    void: ["print", "progress", "rejected"]
  });

•••

•••>script https://unpkg.com/magic-portal !below
https://unpkg.com/magic-portal
•••

•••js
return new Promise((resolve,reject) => {
  let myWorker;
  try {
    myWorker = new Worker('gitworker.js')
    myWorker.onmessage = (ev) => {
      if (ev.data === 'done') resolve(ev.data)
      else console.log(ev.data)
    }
    myWorker.onerror = (err) => {
      resolve({msg: "worker.onerror: " + err.message + " (" + err.filename + ":" + err.lineno + ")", err, err},)
    }
  } catch(err) {
    resolve({msg: "Caught err", err})
  }
  
})
•••


•••js
  // alert("Running")
  const $ = id => document.getElementById(id);

  let worker = new Worker("gitworker.js");
  const portal = new MagicPortal(worker);
  worker.addEventListener("message", ({ data }) => console.log(data));

  const mainThread = {
    async print(message) {
      console.log(message)
    },
    async progress(evt) {
      console.log(evt.phase, evt.total ? evt.loaded / evt.total : 0.5)
      return;
    },
    async fill(url) {
      let username = window.prompt("Username:");
      let password = window.prompt("Password:");
      return { username, password };
    },
    async rejected({ url, auth }) {
      window.alert("Authentication rejected");
      return;
    }, 
    async failure({message}) {
      alert("Failure: ", message)
      return
    },
  }
  portal.set("mainThread", mainThread, {
    void: ["print", "progress", "rejected", "failure"]
  });

async function doCloneAndStuff() {
    console.log("CLONE");

    await workerThread.setDir("/***test***ing");

    await workerThread.clone({
      corsProxy: "https://cors.isomorphic-git.org",
      url: "https://GitHub.com/dotlitdev/dotlit"
    });
    console.log("CLONED!!")

    let branches = await workerThread.listBranches({ remote: "origin" });
    console.log("BRANCHES:\n" + branches.map(b => `  ${b}`).join("\n"))

    let files = await workerThread.listFiles({});
    console.log("FILES:\n" + files.map(b => `  ${b}`).join("\n"))

    let commits = await workerThread.log({});
    console.log("LOG:\n" +
      commits
        .map(c => `  ${c.oid.slice(0, 7)}: ${c.commit.message}`)
        .join("\n"))
  }

  return (async () => {
    const workerThread = await portal.get("workerThread");
    window.workerThread = workerThread
    window.worker = worker
    console.log(workerThread)

    console.log("ready")
    await doCloneAndStuff()

    
  })();
•••
•••>txt attached=true updated=1621342790497
true
•••

•••js
return workerThread.log({})
•••
•••>txt attached=true updated=1621343998003
{ setDir: [Function],
  clone: [Function],
  listBranches: [Function],
  listFiles: [Function],
  log: [Function] }
•••






1. [/testing/fuzzy_text_search.lit](/testing/fuzzy_text_search.lit) 

    > /***test***ing/fuzzy_text_search.lit ... # Fuzzy text search

Related

- [[***test***ing/compact_manifest]]

## Fuse.js

https://fusejs.io/

https://dev.to/noclat/using-fuse-js-with-react-to-build-an-advanced-search-with-highlighting-4b93

•••js !collapse #intro
return (async (fn) => {
  const { default: Fuse } = await import(
    "https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.esm.js"
  );
  const manifest = await fetch("/manifest.json").then((res) => res.json());
  const fuse = new Fuse(manifest.nodes, {
    includeScore: true,
    keys: ["title", "id"],
  });

  // 3. Now search!
  return fuse.search("../../..",{limit:5});
})();

•••
•••js !plugin !collapse type=repl of=search
export const repl = async (src, meta) => {
  const t = Date.now();

  const { default: Fuse } = await import(
    "https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.esm.js"
  );
  // const manifest = await fetch("/manifest.json").then((res) => res.json());
  // Recursively builds JSX output adding `<mark>` tags around matches
  const highlight = (value, indices = [], i = 1) => {
    const pair = indices[indices.length - i];
    return !pair
      ? value
      : `${highlight(
          value.substring(0, pair[0]),
          indices,
          i + 1
        )}***${value.substring(pair[0], pair[1] + 1)}***${value.substring(
          pair[1] + 1
        )}`;
  };
  const fullLocal = await (async (fn) => {
    const path = lit.utils.path;
    const all = [];
    const visit = async (root) => {
      try {
        const list = await lit.fs.readdir(root);
        return Promise.all(
          list.map(async (key) => {
            const pathname = path.join(root, key);
            const stat = await lit.fs.stat(pathname);
            let contents;
            if (key === ".git" || !key) {
            } else if (stat.type === "dir") await visit(pathname);
            else if (pathname.endsWith(".lit"))
              contents = await lit.fs.readFile(pathname, {
                encoding: "utf8",
                localOnly: true,
              }); //.slice(0,10);
            const item = { pathname, type: stat.type, contents };
            all.push(item);
            return item;
          })
        );
      } catch (err) {
        alert(err.message);
      }
    };

    await visit("/");
    return all;
  })();

  // return fullLocal

  const fuse = new Fuse(fullLocal, {
    ignoreLocation: true,
    includeScore: true,
    includeMatches: true,
    ignoreFieldNorm: true,
    minMatchCharLength: 4,
    keys: ["pathname", "contents"],
  });

  // 3. Now search!
  const query = src.trim();
  const msg = `Results for search "**${query}**". In **${
    (Date.now() - t) / 1000
  }** seconds.\n\n`;

  return (
    msg +
    fuse
      .search(query, { limit: 10 })
      //.map(x=>x.matches.map(x=>x.indices))
      .map((x) => [x.score, x.item.pathname, x.refIndex, x.matches])
      .map(
        ([score, pathname, index, matches]) => `1. [${pathname}](${pathname}) 

    > ${matches
      .map(({ indices, value }) => highlight(value, indices))
      .join(" ... ")}`
      )
      .join("\n")
  );
};

•••
•••js search.jsx !plugin !collapse type=viewer Babel=true of=search2
import Fuse from "https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.esm.js";
export const viewer = ({ node, React }) => {

  const {useEffect,u***seSt***ate} = React
  const [msg, setMsg] = u***seSt***ate('Searching...')
  // const manifest = await fetch("/manifest.json").then((res) => res.json());

  // Recursively builds JSX output adding `<mark>` tags around matches
  const highlight = (value, indices = [], i = 1) => {
    const pair = indices[indices.length - i];
    return !pair ? (
      value
    ) : (
      <>
        {highlight(value.substring(0, pair[0]), indices, i + 1)}
        <mark>{value.substring(pair[0], pair[1] + 1)}</mark>
        {value.substring(pair[1] + 1)}
      </>
    );
  };

  const fullLocal = async (fn) => {
    const path = lit.utils.path;
    const all = [];
    const visit = async (root) => {
      try {
        const list = await lit.fs.readdir(root);
        return Promise.all(
          list.map(async (key) => {
            const pathname = path.join(root, key);
            const stat = await lit.fs.stat(pathname);
            let contents;
            if (key === ".git" || !key) {
            } else if (stat.type === "dir") await visit(pathname);
            else if (pathname.endsWith(".lit"))
              contents = await lit.fs.readFile(pathname, {
                encoding: "utf8",
                localOnly: true,
              }); //.slice(0,10);
            const item = { pathname, type: stat.type, contents };
            all.push(item);
            return item;
          })
        );
      } catch (err) {
        alert(err.message);
      }
    };

    await visit("/");
    return all;
  };

  // return fullLocal

  useEffect(async fn => {
     const t = Date.now();
const fuse = new Fuse(await fullLocal(), {
    ignoreLocation: true,
    includeScore: true,
    includeMatches: true,
    ignoreFieldNorm: true,
    minMatchCharLength: 4,
    keys: ["pathname", "contents"],
  });

  // 3. Now search!
  const query = node.data.value.trim();

  return (
    <div>
      <span>{msg}</span>
    </div>
  );
};

•••



•••text repl=search > md
***test***
•••
•••>md attached=true updated=1621893672161
Results for search "*****test*****". In **0.07** seconds.

1. [/***test***ing/lightningfs.lit](/***test***ing/lightningfs.lit) 
1. [/***test***ing/isomorphic_git.lit](/***test***ing/isomorphic_git.lit) 
1. [/***test***ing/fuzzy_text_search.lit](/***test***ing/fuzzy_text_search.lit) 
1. [/***test***ing/serviceworker.lit](/***test***ing/serviceworker.lit) 
1. [/***test***ing/importing_js_modules.lit](/***test***ing/importing_js_modules.lit) 
1. [/***test***ing/input_buffer.lit](/***test***ing/input_buffer.lit) 
1. [/***test***ing/local_remote_files.lit](/***test***ing/local_remote_files.lit) 
1. [/***test***ing/autoformatting_cell_source.lit](/***test***ing/autoformatting_cell_source.lit) 
1. [/***test***ing/runkit.lit](/***test***ing/runkit.lit) 
1. [/***test***ing/compact_manifest.lit](/***test***ing/compact_manifest.lit) 
•••

•••>md updated=1621870142091
Results for search "**fuzz**". In **0.074** seconds.

1. [/***test***ing/fuzzy_text_search.lit](/***test***ing/fuzzy_text_search.lit) 0.000001
1. [/***test***ing/log/2021-05-23.lit](/***test***ing/log/2021-05-23.lit) 0.001
1. [/functions.lit](/functions.lit) 0.25
1. [/***test***ing/input_buffer.lit](/***test***ing/input_buffer.lit) 0.25
1. [/***test***ing/full.json](/***test***ing/full.json) 0.5
1. [/utils/functions.js](/utils/functions.js) 0.5
1. [/index.lit](/index.lit) 0.5
1. [/execute_code_cells.lit](/execute_code_cells.lit) 0.5
1. [/plugin_system.lit](/plugin_system.lit) 0.5
1. [/scratch_pad.lit](/scratch_pad.lit) 0.5
1. [/prismjs_and_a_simple_editor.lit](/prismjs_and_a_simple_editor.lit) 0.5
1. [/***test***ing/lightningfs.lit](/***test***ing/lightningfs.lit) 0.5
1. [/***test***ing/isomorphic_git.lit](/***test***ing/isomorphic_git.lit) 0.5
1. [/***test***ing/runkit.lit](/***test***ing/runkit.lit) 0.5
1. [/***test***ing/selection.lit](/***test***ing/selection.lit) 0.5
•••





## FuzzySet

https://github.com/Glench/fuzzyset.js

•••js
return import('https://cdn.skypack.dev/fuzzyset').then( FuzzySet => {

  const f = new FuzzySet.default()
  f.add("the text of mine")
  f.add("the text of someone else")
  f.add("other texts")
  return f.get("text of")
})

•••
•••>txt attached=true updated=1621778112764
[ [ 0.4375, 'the text of mine' ] ]
•••

1. [/testing/serviceworker.lit](/testing/serviceworker.lit) 

    > /***test***ing/serviceworker.lit ... # Service Worker

•••js exec=onload !collapse
return fetch("--sw")
  .catch((err) => err.message)
  .then((res) => res.text());

•••

## Table of Contents

## References 

- https://ponyfoo.com/articles/serviceworker-revolution
- https://github.com/homam/service-workers-example
- Communication 
  - ~[broadcast channels](https://stackoverflow.com/a/66784901/371040)~ not available in safari, desktop or iOS 
- Initial source, from: https://googlechrome.github.io/samples/service-worker/basic/
- https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent/respondWith
- https://stackoverflow.com/questions/44424709/passing-state-info-into-a-service-worker-before-install
- https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch


See [[***test***ing/Web Workers]] for related investigation.

## Exploration
•••js
return navigator
•••
•••>txt attached=true updated=1619869271361
{}
•••

•••js
if ('serviceWorker' in navigator) {
  return true
}
•••
•••>txt attached=true updated=1619524117633
true
•••


•••js #register
return navigator
          .serviceWorker
          .register('/serviceworker.js?root='+lit.location.root)
•••
•••>txt attached=true updated=1621682807522
{}
•••

•••js #status
return navigator.serviceWorker.controller
         ? "Service worker active."
         : "Service worker Not active."
•••
•••>txt attached=true updated=1621861739207
Service worker active.
•••

•••js #unregister
return (async fn => {
  const regs = await navigator
                     .serviceWorker
                     .getRegistrations()
  for(let registration of regs) {
    console.log(registration)
    registration.unregister()
  }
  return `Unregistered ${regs.length} regisration(s)`
})()
•••
•••>txt attached=true updated=1621716614935
{}
Unregistered 1 regisration(s)
•••
•••js
return fetch('/none')
       .then( resp => resp.status )
•••
•••>txt attached=true updated=1620028398727
404
•••
•••js
return fetch('/manifest.json')
       .then(resp => resp.status)
•••
•••>txt attached=true updated=1619884198845
200
•••
•••js
return (new Response('hello')).text()
•••
•••>txt attached=true updated=1619524123503
hello
•••

As of now, the service worker doesn't cache anything and just pa***sses*** through to the network as normal. Except if the `request.url` ends with `--sw` in which case it returns a mock/info response.
•••js
return fetch('--sw')
       .then(resp => resp.text()
                          .then( text => `${resp.status}\n${text}`)
       )
•••
•••>txt attached=true updated=1621684367869
200
{
  "version": "0.2.8",
  "dotlit": "object",
  "root": "",
  "enableCache": false,
  "filepath": "/***test***ing/",
  "stat": {
    "type": "dir",
    "mode": 511,
    "size": 0,
    "ino": 1,
    "mtimeMs": 1621200461729,
    "ctimeMs": 1621200461729,
    "uid": 1,
    "gid": 1,
    "dev": 1
  }
}
•••


•••text < ./g***etse***rviceworker--sw 

•••

## Implementation

•••>js ../serviceworker.js !collapse #implementation
// gross hack around one of @codemirror/view bugs
let document = { documentElement: { style: {} } };

importScripts("web.bundle.js");

const state = {
  version: "0.2.12",
  dotlit: typeof dotlit,
  root: "",
  enableCache: false,
};

const PRECACHE = "precache-v1";
const RUNTIME = "runtime";

// A list of local resources we always want to be cached.
const PRECACHE_URLS = [
  //'index.html',
  //'./', // Alias for index.html
  //'styles.css',
  //'../../styles/main.css',
  //'demo.js'
];

const getMockResponse = async (event) => {
  try {
    if (typeof dotlit !== "undefined") {
      const filepath = event.request.url
        .slice(dotlit.lit.location.base.length - 1, -4)
        .slice();
      const stat = await dotlit.lit.fs.stat(filepath);
      const status = {
        ...state,
        filepath,
        stat,
      };
      return new Response(JSON.stringify(status, null, 2), {
        headers: { meta: state.version },
      });
    }
  } catch (err) {
    const status = {
      ...state,
      url: event.request.url,
      err: err.message,
    };
    return new Response(JSON.stringify(status, null, 2));
  }
};

const localFile = async (event) => {
  if (typeof dotlit !== "undefined") {
    const filepath = event.request.url
      .slice(dotlit.lit.location.base.length - 1)
      .slice();
    await dotlit.lit.fs.stat(filepath);
    let jsFile;
    if (/.*\.m?jsx?$/.***test***(filepath)) {
      jsFile = true;
    }
    const content = await dotlit.lit.fs.readFile(filepath, { localOnly: true });
    return new Response(content, {
      headers: {
        server: `dotlit.org/sw@${state.version}`,
        jsFile: jsFile,
        "Content-Type": jsFile ? "text/javascript" : "text/plain",
      },
    });
  } else throw new Error("dotlit module not loaded.");
};

// The install handler takes care of precaching the resources we always need.
self.addEventListener("install", (event) => {
  state.root = new URL(location).searchParams.get("root");
  event.waitUntil(
    caches
      .open(PRECACHE)
      .then((cache) => cache.addAll(PRECACHE_URLS))
      .then(self.skipWaiting())
  );
});

// The activate handler takes care of cleaning up old caches.
self.addEventListener("activate", (event) => {
  const currentCaches = [PRECACHE, RUNTIME];
  event.waitUntil(
    caches
      .keys()
      .then((cacheNames) => {
        return cacheNames.filter(
          (cacheName) => !currentCaches.includes(cacheName)
        );
      })
      .then((cachesToDelete) => {
        return Promise.all(
          cachesToDelete.map((cacheToDelete) => {
            return caches.delete(cacheToDelete);
          })
        );
      })
      .then(() => self.clients.claim())
  );
});

// The fetch handler serves responses for same-origin resources from a cache.
// If no response is found, it populates the runtime cache with the response
// from the network before returning it to the page.
self.addEventListener("fetch", (event) => {
  // Skip cross-origin requ***ests***, like those for Google Analytics. And add mock response
  if (event.request.url.startsWith(self.location.origin)) {
    if (event.request.url.endsWith("--sw")) {
      console.log("Mock/Info request");
      event.respondWith(getMockResponse(event));
    } else {
      event.respondWith(
        localFile(event)
          .then((file) => {
            console.log("Responding with", file);
            return file;
          })
          .catch((err) => {
            console.log("Failed local file check, reverting to network", err);
            return caches.match(event.request).then((cachedResponse) => {
              if (state.enableCache && cachedResponse) {
                return cachedResponse;
              }

              return caches.open(RUNTIME).then((cache) => {
                return fetch(event.request)
                  .then((response) => {
                    // Put a copy of the response in the runtime cache.
                    return cache
                      .put(event.request, response.clone())
                      .then(() => {
                        return response;
                      });
                  })
                  .catch((err) => {
                    if (!cachedResponse) throw err;
                    return cachedResponse;
                  });
              });
            });
          })
      );
    }
  }
});

•••

1. [/testing/importing_js_modules.lit](/testing/importing_js_modules.lit) 

    > /***test***ing/importing_js_modules.lit ... # Importing JS Modules

## Table of Contents 

## References

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules
- https://github.com/WICG/import-maps
- https://github.com/tc39/proposal-import-meta
- https://v8.dev/features/modules
- https://jakearchibald.com/2017/es-modules-in-browsers/

•••js #destructuring
const x = {
  default: "a",
  b: "42",
  c: () => {},
};
const { default: y, b: z } = x;
return { y, z };

•••
•••>txt attached=true updated=1621550583088
{ y: 'a', z: '42' }
•••

## Skypack





•••js #skypack
const skypack = (pkg) => import(`https://cdn.skypack.dev/${pkg}`);
return skypack("canvas-confetti");

•••
•••>txt attached=true updated=1621634750440
{ create: [Function: confettiCannon],
  default: { [Function: fire] r***eset***: [Function], create: [Function: confettiCannon] } }
•••
•••js #skypack
const skypack = (pkg) => import(`https://cdn.skypack.dev/${pkg}`);

return skypack("canvas-confetti").then((pkg) => {
  const { default: fire } = pkg;
  return fire();
});

•••
•••>txt attached=true updated=1621551049304
undefined
•••
•••js #skypack
const skypack = (pkg) => import(`https://cdn.skypack.dev/${pkg}`);

// I like async await
return (async (fn) => {
  const { default: fire } = await skypack("canvas-confetti");
  return fire();
})();

•••
•••>txt attached=true updated=1621551042809
undefined
•••

## Unpkg



•••js #unpkg
const unpkg = (pkg) => import(`https://unpkg.com/${pkg}?module`);
return unpkg("canvas-confetti");

•••
•••>txt attached=true updated=1621550434223
{ create: [Function: confettiCannon],
  default: { [Function: fire] r***eset***: [Function], create: [Function: confettiCannon] } }
•••
•••js #unpkg
const unpkg = (pkg) => import(`https://unpkg.com/${pkg}?module`);
return unpkg("canvas-confetti").then((pkg) => {
  return pkg.default();
});

•••
•••>txt attached=true updated=1621583914027
undefined
•••



## Native ES Module REPL
•••>js ../plugins/repls/module.js !plugin type=repl of=module !collapse 
export const repl = async (src, meta) => {
  const { btoa } = lit.utils.safeEncoders;
  const { transform } = lit.utils;
  const filename = (meta && meta.filename) || "untitled.js";
  let babel;
  try {
    babel = transform(filename, src);

    // So many hacks due to blob and/or data uri
    // - cachbusting comment
    // - rewrite imports urls to be absolute
    const s =
      `/*${Date.now()}*/` +
      babel.code.replace(
        /HORRIBLE_HACK([^'"]+)/g,
        //location.href
        new URL(".", location.href).toString() + "$1"
      );
    const console = "fake me";
    // const url = `data:text/javascript;base64,${btoa(s)}`
    const url = URL.createObjectURL(new Blob([s], { type: "text/javascript" }));
    const m = await import(url + "#location=" + location.href);
    if (typeof m.default === "function") {
      const res = await m.default.call({ console });
      return lit.utils.inspect(res);
    } else return lit.utils.inspect(m);
  } catch (err) {
    return err.message;
  }
};

•••
•••js repl=module
import fire from "https://cdn.skypack.dev/canvas-confetti";

export const success = "yes";
export const issue =
  "module caching means it only executes once, had to add a cachebusting comment.";

export default () => import.meta
export const cons = typeof console !== "undefined" ? console : null;
fire();

•••
•••>txt attached=true updated=1621688470869
{ url: 'blob:https://dotlit.org/f371b8d7-12a1-49d1-b9c6-ff6373727cf6#location=https://dotlit.org/***test***ing/importing_js_modules.html?file=***test***ing/importing_js_modules.lit#../plugins/repls/module.js' }
•••


•••js repl=module
import foo from '/notfound.js'
export default foo
•••
•••>txt attached=true updated=1621705508196
Module name, '/notfound.js' does not resolve to a valid URL.
•••
•••>txt  updated=1621596754673
Module name, '/notfound' does not resolve to a valid URL.
•••
•••>txt  updated=1621596671506
Module specifier, 'notfound' does not start with "/", "./", or "../". Referenced from data:text/javascript;base64,LyoxNjIxNTk2NjcxNDkzKi9pbXBvcnQgZm9vIGZyb20gJ25vdGZvdW5kJzsKZXhwb3J0IGRlZmF1bHQgZm9vOw==
•••
•••js repl=module
export default async function (...args) {
  return { args, console, ctx: this };
};

•••
•••>txt attached=true updated=1621599908036
{ args: [],
  console: 
   { debug: [Function],
     error: [Function],
     log: [Function],
     info: [Function],
     warn: [Function],
     clear: [Function],
     dir: [Function],
     dirxml: [Function: dirxml],
     table: [Function],
     trace: [Function: trace],
     assert: [Function],
     count: [Function],
     countR***eset***: [Function],
     profile: [Function: profile],
     profileEnd: [Function: profileEnd],
     time: [Function],
     timeLog: [Function],
     timeEnd: [Function],
     timeStamp: [Function: timeStamp],
     takeHeapSnapshot: [Function: takeHeapSnapshot],
     group: [Function],
     groupCollapsed: [Function],
     groupEnd: [Function],
     record: [Function: record],
     recordEnd: [Function: recordEnd],
     screenshot: [Function: screenshot] },
  ctx: { console: 'fake me' } }
•••

•••js repl=module
export default fn => console.screenshot(document.body)
•••
•••>txt attached=true updated=1621600683102
undefined
•••

•••js repl=module
const { inspect } = lit.utils;
const { wait } = lit.utils.fns;

export default async (fn) => {
  // https://github.com/whatwg/console/issues/120
  console.record();
  await wait(1000);
  console.log("tick", new Date());
  await wait(1000);
  console.log("tock", new Date());
  return console.recordEnd.toString();
};

•••
•••>txt attached=true updated=1621600089887
'function recordEnd() {\n    [native code]\n}'
•••

## Local modules

This assumes you have the *experimental* service worker ([[***test***ing/ServiceWorker]]) (version 0.2.10) enabled to vend files in the local filesystem via Web fetch API.

•••>js custom-module.mjs
export default (fn) => "Great Success!";

•••

•••js
const url = new URL("./foo", location.href)
return url.toString()
•••
•••>txt attached=true updated=1621688183147
https://dotlit.org/***test***ing/foo
•••

•••js repl=module
import foo from "HORRIBLE_HACKcustom-module.mjs";
export const ***test***1 = "HORRIBLE_HACKfoo";
export const ***test***2 = new URL("HORRIBLE_HACKcustom-module.mjs").toString();
export const meta = import.meta;
export default foo();

•••
•••>txt attached=true updated=1621707123525
{ default: 'Great Success!',
  meta: { url: 'blob:https://dotlit.org/b269801f-a29f-49b2-9ebd-00ba04e7ad5b#location=https://dotlit.org/***test***ing/importing_js_modules.html?file=***test***ing/importing_js_modules.lit#' },
  ***test***1: 'https://dotlit.org/***test***ing/foo',
  ***test***2: 'https://dotlit.org/***test***ing/custom-module.mjs' }
•••

The correct resolution to the above hacks https://www.npmjs.com/package/babel-plugin-bare-import-rewrite
•••>txt  updated=1621690705217
'Great Success!'
•••
•••>txt  updated=1621687020245
Module name, './***test***ing/custom-module.mjs' does not resolve to a valid URL.
•••
•••>txt  updated=1621686958336
{ url: 'blob:https://dotlit.org/cda4db85-6121-4041-b417-46e4de9dfe08#path=***test***ing/importing_js_modules.lit' }
•••

•••js
return fetch('/***test***ing/custom-module.mjs').then(res => res.headers.get('Content-Type'))
•••
•••>txt attached=true updated=1621686964618
text/javascript
•••


- [x] ~Seems like `0.2.2` is *Still* not ***sett***ing headers correctly, was expecting~ Got `text/javascript`.
- [ ] fetch/sw now sends correct mime type, but still get `Module name, '/***test***ing/custom-module.mjs' does not resolve to a valid URL.`
•••js
return fetch('/***test***ing/custom-module.mjs--sw').then(res => res.text())
•••
•••>txt attached=true updated=1621686173489
{
  "version": "0.2.10",
  "dotlit": "object",
  "root": "/",
  "enableCache": false,
  "filepath": "/***test***ing/custom-module.mjs",
  "stat": {
    "type": "file",
    "mode": 438,
    "size": 41,
    "ino": 198,
    "mtimeMs": 1621634337946,
    "ctimeMs": 1621634337946,
    "uid": 1,
    "gid": 1,
    "dev": 1
  }
}
•••
•••js
return fetch('/***test***ing/custom-module.mjs').then(res => res.headers.get('server'))
•••
•••>txt attached=true updated=1621686224492
dotlit.org/sw@0.2.10
•••


- [x] ~After updating the service worker to return the correct mime type~, I suspect it's failing to resolve urls relative to the base64 data:uri setup. c.f. Original repl implementation which uses `createObjectURL`

•••js #extract
const esm = ({ raw }, ...vals) =>
        URL.createObjectURL(
          new Blob([String.raw({ raw }, ...vals)], { type: "text/javascript" })
        );
•••













1. [/testing/input_buffer.lit](/testing/input_buffer.lit) 

    > /***test***ing/input_buffer.lit ... # Input Buffer

•••js !collapse exec=onload !hidemeta < log/checkforinput.js > md !info
// See implementation below for details
•••
•••>md !warn attached=true updated=1620722266322
👀 *Checking for input...*
•••

•••js exec=onload !collapse !hidemeta < log/today.js > md !bigger
const date = new Date();
const isoDate = date.toISOString().split("T")[0];
const today = isoDate;
const year = date.getFullYear();
const month = isoDate.split("-").slice(0, -1).join("-");

const firstDayOfYear = new Date(year, 0, 1);
const pastDaysOfYear = (date - firstDayOfYear) / 86400000;
const week = [
  year,
  "w" + Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7),
].join("-");

const prefix = `/***test***ing/log/`;
const pathFor = (log) => `${prefix}${log}.lit`;

const checkForTodayFile = async () => {
  let stat;
  try {
    stat = await lit.fs.readStat(pathFor(today));
  } catch (err) {}
  return `*Today* is [**${today}**](${pathFor(today)}), a log exists: *${
    !!stat && !!(stat.local.stat || stat.remote.stat)
  }*; See [week](${pathFor(week)}), [month](${pathFor(
    month
  )}) or [year](${pathFor(year)}).`;
};

return checkForTodayFile();

•••
•••>md !bigger attached=true updated=1621777505326
*Today* is [**2021-05-23**](/***test***ing/log/2021-05-23.lit), a log exists: *true*; See [week](/***test***ing/log/2021-w22.lit), [month](/***test***ing/log/2021-05.lit) or [year](/***test***ing/log/2021.lit).
•••

## Table of Contents

## About

*Inspired by [mymind](https://twitter.com/mymind) iOS app, [Blackbox](https://twitter.com/BlackboxPuzzles) iOS game and terrible iOS clipboards.*

**aka:** [Peripheral](https://en.m.wikipedia.org/wiki/Peripheral), Input, AUX (Auxiliary)

[![logo](https://www.electronics-tutorials.ws/wp-content/uploads/2013/08/log35.gif?fit=161%2C59)](https://www.electronics-tutorials.ws/logic/logic_9.html)

> A peripheral or peripheral device is  an auxiliary device used to put information into and get information out of the computer.

> peripheria, from Ancient Greek περιφέρεια (periphéreia, “the line around the circle, circumference, part of a circle, an arc, the outer surface”)

Universal ios sharesheet ~~app~~webapp, anything shared to the app is stored, catelogued, linked and editable, sortable, searchable and explorable offline in the app.

> I'm prepared to wait as long as needed for Elon Musks NeuraLink to reach primetime but, We cant afford to sit around till then, we need incremental improvements of our Peripherals, over the Keyboard, Mouse and Touch Screens we have today.
### Bookmarklet



•••js !inline viewer=bookmarklet id=Input !hidemeta
window.location.href = "https://dotlit.org/***test***ing/input_buffer.html?input=" + encodeURIComponent("- [ ] ["+document.title+"]("+location.href+")")
•••
### iOS shortcut

[Lit 🔥 Input](https://www.icloud.com/shortcuts/7c5e088085e34d7d981aace463dcba51) an iOS shortcut which enables sending stuff from anywhere the iOS sharesheet is available, including highlighted text snippets etc, to this (your) Input Buffer.


## Implementation

### Bugs and Todos

- [ ] `exec=onload` output is *still* buggy.
- [ ] Search 🔍
•••js !collapse #mockinput > md
const qs = location.search.slice(1)
return `Here's a [Mock Input](?${qs + (qs ? '&' : '')}input=${encodeURIComponent("- [ ] some **Input** " + new Date())}) to ***test*** input capture.`
•••
•••>md attached=true updated=1621167143944
Here's a [Mock Input](?file=***test***ing/input_buffer.lit&input=-%20%5B%20%5D%20some%20**Input**%20Sun%20May%2016%202021%2013%3A12%3A23%20GMT%2B0100%20(BST)) to ***test*** input capture.
•••

### Core


•••>js log/checkforinput.js !collapse
const date = new Date();
const isoDate = date.toISOString().split("T")[0];
const today = isoDate;
const year = date.getFullYear();
const month = isoDate.split("-")[1];

const firstDayOfYear = new Date(year, 0, 1);
const pastDaysOfYear = (date - firstDayOfYear) / 86400000;
const week = Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);

const filename = (t) => `***test***ing/log/${t}.lit`;

const checkForInput = async () => {
  const insp = lit.utils.inspect;
  const qs = lit.utils.querystring;

  const search = location.search;
  const query = search && qs.parse(search.slice(1));

  if (query?.input) {
    const input = query.input;
    delete query.input;
    const qsWoInput = qs.stringify(query);
    window.history.replaceState(null, null, "?" + qsWoInput);

    let stat = { local: {}, remote: {} };
    try {
      stat = await lit.fs.readStat(`/${filename(today)}`, { encoding: "utf8" });
    } catch (err) {}
    const newContent =
      ((stat.local.stat && stat.local.value) ||
        stat.remote.value ||
        `# ${today}

See [week ${week}](/${filename(
          year + "-w" + week
        )}), [month ${month}](/${filename(
          year + "-" + month
        )}) or [year ${year}](/${filename(year)})
`) +
      ("\n" + input);
    await lit.fs.writeFile(`/${filename(today)}`, newContent);
    return `***Captured Input (below) to [${today}](/${filename(today)})***

${input}`;
  } else {
    return "*No input detected.*";
  }
};
return checkForInput();

•••



•••>js log/today.js !collapse
const date = new Date();
const isoDate = date.toISOString().split("T")[0];
const today = isoDate;
const year = date.getFullYear();
const month = isoDate.split("-").slice(0, -1).join("-");

const firstDayOfYear = new Date(year, 0, 1);
const pastDaysOfYear = (date - firstDayOfYear) / 86400000;
const week = [
  year,
  "w" + Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7),
].join("-");

const prefix = `/***test***ing/log/`;
const pathFor = (log) => `${prefix}${log}.lit`;

const checkForTodayFile = async () => {
  let stat;
  try {
    stat = await lit.fs.readStat(pathFor(today));
  } catch (err) {}
  return `*Today* is [**${today}**](${pathFor(today)}), a log exists: *${
    !!stat && !!(stat.local.stat || stat.remote.stat)
  }*; See [week](${pathFor(week)}), [month](${pathFor(
    month
  )}) or [year](${pathFor(year)}).`;
};

return checkForTodayFile();

•••

•••>html !below !collapse #styling
<style>
.dir-bigger {
  font-size: 1.2em;
}
</style>
•••


•••lit !collapse #template < log/day.lit

•••
•••js !plugin !collapse type=viewer of=bookmarklet
export const viewer = ({ node, React }) => {
  const rc = React.createElement;
  const meta = node.properties.meta;
  const href = `javascript:(function(){${node.data.value}})()`;
  return rc("span", null, [
    "Bookmarklet: ",
    rc("a", { href: href }, `Run ${meta && meta.id ? meta.id : "bookmarklet"}`),
    " href: ",
    rc("pre", null, rc("code", null, href)),
  ]);
};

•••























1. [/testing/local_remote_files.lit](/testing/local_remote_files.lit) 

    > /***test***ing/local_remote_files.lit ... # Local and Remote files

On load `.lit` determines the `src` and `root` and checks both local file system ([[***test***ing/LightningFS]]) and the remote host (ie GitHub pages, or local/remote server) and compares `last-updated` (or Stat `mtimeMs` in the case of local filesystem)

The problem is, that deployment to GitHub pages results in a remote file that *seems* newer than the local file that created it.

## Potential solutions

- Disable (appropriately) GitHub Pages cache

  https://stackoverflow.com/questions/12556593/determining-a-page-is-outdated-on-github-pages
- Read from api instead of pages static file server when Authenticated
  - Potentially read and write to `gh-pages` directly, eschewing Actions deployment entirely.
  - [x] Currently reading and writing to GitHub api when token is available. **Breaks reading generated files like : manifest.json**
- Compare hashes of the content [stackoverflow crypto](https://stackoverflow.com/questions/18338890/are-there-any-sha-256-javascript-implementations-that-are-generally-considered-t/48161723#48161723)

•••txt ***test***.txt remote=true < ***test***.txt
Q
•••
•••js
return lit.fs.readFile('/manifest.json')
•••


1. [/testing/autoformatting_cell_source.lit](/testing/autoformatting_cell_source.lit) 

    > /***test***ing/autoformatting_cell_source.lit ... # Autoformatting Cell Source
## ... with prettier

Homepage https://prettier.io

•••js babel=true #reference
import prettier from "https://unpkg.com/prettier@2.3.0/esm/standalone.mjs";
import parserBabel from "https://unpkg.com/prettier@2.3.0/esm/parser-babel.mjs";

console.log(
  prettier.format("const html=/* HTML */ `<DIV> </DIV>`", {
    parser: "babel",
    plugins: [parserBabel],
  })
);

•••

•••js #***test*** > js #formatted
return (async fn => { // intentionally [sic] badly formatted 
const p = await import(

'https://unpkg.com/prettier@2.3.0/esm/standalone.mjs')
           
              const b = await 
          import('https://unpkg.com/prettier@2.3.0/esm/parser-babel.mjs')
const format 
= p.default.format
const babelPlugin 
= b.default


  const thisCellsSource = this.children[0].children[0].data.value


return format(thisCellsSource, { parser: "babel",plugins: [babelPlugin]})
})()
•••
•••>js #formatted attached=true updated=1621285984079
return (async (fn) => {
  // intentionally [sic] badly formatted
  const p = await import("https://unpkg.com/prettier@2.3.0/esm/standalone.mjs");

  const b = await import(
    "https://unpkg.com/prettier@2.3.0/esm/parser-babel.mjs"
  );
  const format = p.default.format;
  const babelPlugin = b.default;

  const thisCellsSource = this.children[0].children[0].data.value;

  return format(thisCellsSource, { parser: "babel", plugins: [babelPlugin] });
})();

•••

Implementing as a transformer `!plugin`

•••>js ../plugins/transformers/prettier.js !plugin type=transformer of=prettier id=prettier
export const transformer = async ({
  node,
  src,
  codeSource,
  rawSource,
  originalSource,
}) => {
  const lines = src.split("\n");
  let [first, ...rest] = lines;
  let middle = rest.slice(0, -1);
  const [last] = rest.slice(-1);
  const body = middle.join("\n");

  const p = await import("https://unpkg.com/prettier@2.3.0/esm/standalone.mjs");
  const b = await import(
    "https://unpkg.com/prettier@2.3.0/esm/parser-babel.mjs"
  );

  const format = p.default.format;
  const babelPlugin = b.default;
  try {
    return [
      first,
      format(body, { parser: "babel", plugins: [babelPlugin] }),
      last,
    ].join("\n");
  } catch (err) {
    lit.file.message(err.message);
    return src;
  }
};

•••

•••js transformer=prettier
// make me
         // prettier
//...
                          // thanks

return async fn=>{}

•••

edit and save the above cell to have it automatically formatted by Prettier using the transformer `!plugin` implemented above.

1. [/testing/runkit.lit](/testing/runkit.lit) 

    > /***test***ing/runkit.lit ... # ***test***ing/runkit.lit

Experimenting using [RunKit](https://runkit.com) as a custom repl for nodejs. Warning, it starts off messy, but in the end we have a reusable `nodejs` custom REPL.

## Table of Contents

## Embed

Lets start with just the simple [demo embed,](https://runkit.com/docs/embed) adding the embed script and a container below.

•••script https://embed.runkit.com !inline
// injecting https://embed.runkit.com script
•••

•••html !inline
<!-- anywhere else on your page -->
<div id="my-element">A container to hold the embed.</div>
•••

Run the #init cell below 👇 to populate it With some demo source.



•••js #init !collapse
return RunKit.createNotebook({
    // the parent element for the new notebook
    element: document.getElementById("my-element"),
    onEvaluate: (...args) => alert(JSON.stringify([...args])),
    // specify the source of the notebook
    source: "// GeoJSON!\nvar getJSON = require(\"async-get-json\");\n\nawait getJSON(\"https://storage.googleapis.com/maps-devrel/google.json\");"
})
•••


## Endpoint

react bindings for simple embed: https://github.com/runkitdev/react-runkit and trying out https://runkit.com/docs/endpoint


•••jsx babel=true react=true repl=js !below #react #endpoint 
return (async fn => {

  const React = lit.utils.React
  const Embed = (await import('https://cdn.skypack.dev/runkit-embed-react')).default

  const createdAt = new Date()

  const helloSource = `exports.endpoint = function(request, response) {
    response.end("Hello world! From .lit and Nodejs thanks to RunKit. Created at " + createdAt);
}`

  const onLoad = (...args) => console.log(JSON.stringify([...args]))

  return <Embed
            mode='endpoint'
            readOnly={true}
            evaluateOnLoad={true}
            // hidesActionButton={true}
            source={ helloSource } 
            // ref='embed'
            onLoad={ onLoad } 
          />

})()
•••

•••uri !below
https://2mkz0r1anfrl.runkit.sh/
•••
## Viewer plug-in

•••jsx rk.jsx !collapse !plugin type=viewer of=runkit
import Embed from 'https://cdn.skypack.dev/runkit-embed-react'

export const viewer = ({node,React}) => {
  const {u***seSt***ate} = React
  const [url, setUrl] = u***seSt***ate(false)
  const meta = node?.properties?.meta || {}
  const endpoint = meta.attrs && meta.attrs.mode === 'endpoint'

  const onLoad = async (rk) => {
     if (endpoint)
       setUrl(await rk.getEndpointURL())
  }

  return url || <Embed
            mode={endpoint ? 'endpoint' : 'default'}
            readOnly={endpoint}
            evaluateOnLoad={endpoint}
            hidesActionButton={endpoint}
            source={ node.data.value } 
            // ref='embed'
            onLoad={ onLoad } 
          />

}
•••

•••runkit !inline
console.log("Hello world! From .lit and Nodejs thanks to RunKit.")
•••
•••runkit !below mode=endpoint
exports.endpoint = function(req, res) {
    res.end("Hello world! From .lit and Nodejs thanks to RunKit.");
}
•••`
•••runkit !below mode=endpoint
exports.endpoint = function(req,res) {
  res.writeHead(200, {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': '*',
  });
  res.end('{"ping": "pong!"}')
}
•••`

•••js
return fetch("https://jzc0q8a4nyog.runkit.sh").then(res => res.text())
•••
•••>txt attached=true updated=1621030315807
{"ping": "pong!"}
•••

## REPL endpoint plug-in `node`

Split out the endpoint source to its own `.lit` cell for legibility instead of an inline string.

•••>js runkit-repl-endpoint.js !collapse #source
const util = require('util')

function requireFromString(src, filename) {
  var Module = module.constructor;
  var m = new Module();
  m._compile(src, filename);
  return m.exports;
}

exports.endpoint = function(req,res) {
  res.writeHead(200, {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': '*',
  });

  let data = '';
  req.on('data', chunk => {
    data += chunk;
  })

  req.on('end', async () => {
    const payload = JSON.parse(data)
    const exported = requireFromString(payload.src, payload.meta.filename || "untitled.js")
    let result;
    if (typeof exported === 'function') {
      try {
        result = await exported(payload.meta)
        res.end(util.inspect({
          result
        }))
      } catch(error) {
        res.end(util.inspect({error}))
      }
    } else {
      res.end(util.inspect({
        exports: exported
      }))
    }
  })
}
•••

On load the following `repl` `!plugin` creates a RunKit endpoint if it doesn't exist using the above source.

•••js !plugin type=repl of=node !collapse
if (typeof lit !== 'undefined' && !window.__runkitNodeEnpoint) {
  (async fn => {
    const el = document.createElement('div')
    document.body.appendChild(el)
    // el.setAttribute("style", "height:0;")
    RunKit.createNotebook({
      element: el,
      mode: 'endpoint',
      onLoad: async (rk) => { 
        window.__runkitNodeEnpoint = await rk.getEndpointURL()
        // document.body.removeChild(el)
      },
      evaluateOnLoad: true,
      source: await lit.fs.readFile("***test***ing/runkit-repl-endpoint.js", {encoding: 'utf8'})
    })
  })()
}


export const repl = async (src, meta, node) => {
  if (!window.__runkitNodeEnpoint) {
    return "Still ***sett***ing up repl endpoint"
  } else {
    try {
      return await (await fetch(window.__runkitNodeEnpoint, {
        method: "POST",
        body: JSON.stringify({src,meta})
      })).text()
    } catch(err) {
      return err.message
    }
  }
}
•••

*Usage:*
•••js ***test***.js repl=node
module.exports = async (meta) => {
  return `Hello world! From .lit and Nodejs ${process.env.NODE_VERSION} (${process.platform} ${process.arch}) thanks to RunKit. At ${new Date()}`
}
•••
•••>txt attached=true updated=1621287964690
{ result:
   'Hello world! From .lit and Nodejs 10.24.1 (linux x64) thanks to RunKit. At Mon May 17 2021 21:46:04 GMT+0000 (Coordinated Universal Time)' }
•••
•••>txt  updated=1621086966109
{ result:
   'Hello world! From .lit and Nodejs 10.24.1 (linux x64) thanks to RunKit. At Sat May 15 2021 13:56:05 GMT+0000 (Coordinated Universal Time)' }
•••

## Next steps and improvements

- [ ] Don't start the endpoint on every page load, and instead lazily setup just before first execution.
- [ ] Don't use require module from string hack, and instead use a proper `vm` abd context.
1. [/testing/compact_manifest.lit](/testing/compact_manifest.lit) 

    > /***test***ing/compact_manifest.lit ... # Compact Manifest

Reducing the serialised size of a manifest of all files in a `.lit` notebook.

## Trying out [compact-prefix-tree](https://github.com/sidvishnoi/compact-prefix-tree)
•••js
return (async fn => {
  const {CompactPrefixTree} = await import('https://cdn.skypack.dev/compact-prefix-tree')

  const manifest = await fetch('/manifest.json').then(res => res.json())
  const keys = manifest.nodes.map(n=>n.id)
  const trie = new CompactPrefixTree(keys)

  const before = JSON.stringify(keys)
  const after = JSON.stringify(trie.T)
  // console.log(trie.T)
  await lit.fs.writeFile('/***test***ing/compactManifest1.json', after, 'utf8')
  return `A ${after.length/before.length*100}% reduction in size.`
})()
•••
•••>txt attached=true updated=1621379712347
A 91.78470254957507% reduction in size.
•••



Looking up a file, check for existence:
•••js
return (async (fn) => {
  const { CompactPrefixTree, getWordsFromTrie } = await import(
    "https://cdn.skypack.dev/compact-prefix-tree"
  );

  const json = await fetch("/***test***ing/compactManifest1.json").then((res) =>
    res.json()
  );
  // return json
  const keys = getWordsFromTrie(json);
  const trie = new CompactPrefixTree(Array.from(keys));
  return trie.prefix("***test***ing/log/");
})();

•••
•••>txt  updated=1621380328935
{ prefix: '***test***ing/log/day.lit', isProper: true }
•••
•••>txt updated=1621380061074
{ prefix: '', isProper: false }
•••

```

```>md updated=1621870142091
Results for search "**fuzz**". In **0.074** seconds.

1. [/testing/fuzzy_text_search.lit](/testing/fuzzy_text_search.lit) 0.000001
1. [/testing/log/2021-05-23.lit](/testing/log/2021-05-23.lit) 0.001
1. [/functions.lit](/functions.lit) 0.25
1. [/testing/input_buffer.lit](/testing/input_buffer.lit) 0.25
1. [/testing/full.json](/testing/full.json) 0.5
1. [/utils/functions.js](/utils/functions.js) 0.5
1. [/index.lit](/index.lit) 0.5
1. [/execute_code_cells.lit](/execute_code_cells.lit) 0.5
1. [/plugin_system.lit](/plugin_system.lit) 0.5
1. [/scratch_pad.lit](/scratch_pad.lit) 0.5
1. [/prismjs_and_a_simple_editor.lit](/prismjs_and_a_simple_editor.lit) 0.5
1. [/testing/lightningfs.lit](/testing/lightningfs.lit) 0.5
1. [/testing/isomorphic_git.lit](/testing/isomorphic_git.lit) 0.5
1. [/testing/runkit.lit](/testing/runkit.lit) 0.5
1. [/testing/selection.lit](/testing/selection.lit) 0.5
```





## FuzzySet

https://github.com/Glench/fuzzyset.js

```js
return import('https://cdn.skypack.dev/fuzzyset').then( FuzzySet => {

  const f = new FuzzySet.default()
  f.add("the text of mine")
  f.add("the text of someone else")
  f.add("other texts")
  return f.get("text of")
})

```
```>txt attached=true updated=1621778112764
[ [ 0.4375, 'the text of mine' ] ]
```
