<html data-reactroot=""><head><title>Client</title><meta name="litsrc" value="/client/client.lit"/><meta name="litroot" value="/"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/><meta name="apple-mobile-web-app-capable" content="yes"/><link rel="apple-touch-icon" href="/assets/lit-logo.png"/><link rel="icon" href="/assets/lit-logo.png"/><link rel="stylesheet" href="/style.css"/></head><body><div id="lit-app"><div id="lit-header"><menu class="horizontal open has-children"><li class="MenuTitle"><a href="/">Home</a></li><li class="MenuItems"><menu class="has-children" disabled=""><li class="MenuTitle">File</li></menu><menu class="has-children" disabled=""><li class="MenuTitle">Cell</li></menu><menu class="has-children" disabled=""><li class="MenuTitle">Section</li></menu><menu class="has-children" disabled=""><li class="MenuTitle">Help</li></menu><menu class="has-children right"><li class="MenuTitle"><span class="led led-grey"></span><span class="led led-grey"></span><span class="led led-grey"></span></li></menu></li></menu></div><style>body {
  --bg: white;
  --bg-secondary-color: #efefef;
    
  --text-color: black;
  --text-secondary-color: grey;
  --text-primary-color: #9999f7;
  --text-highlight-bg: yellow;
  --text-highlight-color: black;

  --divider-subtle: #efefef;
  --medium-space: 0.4em;
  --code-bg-color: black;
  --code-text-color: white;
  --box-bg-opacity: 0.05;
}</style><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.0.0/build/styles/sunburst.min.css"/><div id="content"><section id="client" depth="1" class="" startpos="1:1-0" endpos="4:156-469"><div startpos="1:1-0" endpos="4:156-469" class="cell"><div class="cell-content"><h1 id="client">Client</h1><p>The static html generated by <code>.lit</code> does not <em>require</em> JavaScript to function for the reader<sup id="fnref-1"><a class="footnote-ref" href="#fn-1">1<span class="linkIcon">ยง</span></a></sup>. But by default includes a client bundle which re-hydrates the page to become fully interactive, enabling editing of the original document in place. See <a class="exists local" href="../components/components.html" title="components/components" wikilink="true" filepath="/client/client.lit" root="" data="[object Object]">components/components</a> for implementation details.</p></div></div><div startpos="6:1-471" endpos="264:4-9593" class="code   cell"><div class="cell-content"><div class="dir-collapse tag-implementation lang-jsx local collapsed codecell"><span class="meta"><span class="lang">jsx</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span style="color:white;background-color:#6455ab" class="tag">implementation</span><span class="source">&lt; index.jsx</span></span><pre><code class="jsx">// IOS indexDB bug workaround
const idb = indexedDB

const {time, getTimings} = require(&#x27;../utils/timings&#x27;)

time(&#x27;client&#x27;)
const React = require(&#x27;react&#x27;)
const ReactDOM = require(&#x27;react-dom&#x27;)
const vfile = require(&#x27;vfile&#x27;)
const path = require(&#x27;path&#x27;)
const qs = require(&#x27;querystring-es3&#x27;)
const FS = require(&#x27;@isomorphic-git/lightning-fs&#x27;)
const git = require(&#x27;isomorphic-git&#x27;)
const compactPrefixTree = require(&#x27;compact-prefix-tree&#x27;)
const mime = require(&#x27;mime-types&#x27;)
const pkg = require(&#x27;../../package.json&#x27;)

const select = require(&#x27;unist-util-select&#x27;)
const source = require(&#x27;unist-util-source&#x27;)
const filter = require(&#x27;unist-util-filter&#x27;)
const visit = require(&#x27;unist-util-visit&#x27;)
const patchSource = require(&#x27;../utils/unist-util-patch-source&#x27;)
const selectPosition = require(&#x27;../utils/unist-util-select-position&#x27;)

const { to_string } = require(&#x27;../parser/utils/mdast-util-to-string&#x27;)

const parser = require(&#x27;../parser&#x27;)
const renderer = require(&#x27;../renderer&#x27;)
const { Repl, transform } = require(&#x27;../repl&#x27;)

const { Header } = require(&#x27;../components/Header&#x27;)
const { extendFs } = require(&#x27;../utils/fs-promises-utils&#x27;)
const momento = require(&#x27;../utils/momento&#x27;)
const colors = require(&#x27;../utils/colors&#x27;)
const safeEncoders = require(&#x27;../utils/safe-encoders&#x27;)

const { inspect } = require(&#x27;util&#x27;)
const diff = require(&#x27;diff&#x27;)
const fns = require(&#x27;../utils/functions&#x27;)
import { getConsoleForNamespace } from &#x27;../utils/console&#x27;
import {setupGithubAccess} from &#x27;../utils/github&#x27;

const console = getConsoleForNamespace(&#x27;client&#x27;)

const  { DatesToRelativeDelta, MsToRelative } = momento

time(&#x27;client&#x27;, &#x27;importsComplete&#x27;)

const hasLocation = typeof location !== &quot;undefined&quot;
const litLocation = getLitLocation()

function getLitLocation () {
    const query = hasLocation ? qs.parse(location.search.slice(1)) : {}
    const litsrcMeta = fns.getMeta(&#x27;src&#x27;, &#x27;&#x27;)
    const litsrc = (litsrcMeta === &#x27;/404.lit&#x27;)
                    ? (query.file || location.pathname.replace(/\.html$/, &#x27;.lit&#x27;).slice(1))
                    : litsrcMeta
    const litroot = fns.getMeta(&#x27;root&#x27;, &#x27;/&#x27;)
    const litbase = (!hasLocation || litroot === &#x27;/&#x27;)
                    ? litroot 
                    : path.join(path.dirname(location.pathname), litroot);
    const baseSuffix = litbase.slice(-1) === &#x27;/&#x27; ? &#x27;&#x27; : &#x27;/&#x27;;
    const baseUrl = hasLocation &amp;&amp; `${location.protocol}//${location.host}${litbase}${baseSuffix}`
    return {
        src: litsrc,
        root: litroot,
        base: baseUrl,
        query: query,
    }
}

const lfs = new FS(litLocation.base, {
    wipe: litLocation.query.__lfs_wipe===&quot;true&quot; ? confirm(&quot;Are you sure you want to wipe the local file system: &quot; + litLocation.base) : undefined,
    url: litLocation.base,
})

let ghSettings
if (typeof localStorage !== &#x27;undefined&#x27;) {
  try {
    ghSettings = JSON.parse(localStorage.getItem(&#x27;ghSettings&#x27;))
  } catch(err) {}
}
const fs = extendFs(lfs.promises, litLocation.root, !litLocation.query.__no_gh &amp;&amp; ghSettings)

time(&#x27;client&#x27;, &#x27;fsSetup&#x27;)

export const lit = {
    version: pkg.version,
    location: litLocation,
    getTimings,
    parser,
    renderer,
    Repl,
    config: {
        setupGithubAccess
    },
    fs, lfs, git,
    utils: {
        transform,
        inspect,
        compactPrefixTree,
        diff,
        mime,
        React,
        ReactDOM,
        unist: {
            select,
            source,
            filter,
            visit,
            patchSource,
            selectPosition,
        },
        mdast: {
            to_string,
        },
        momento,
        colors,
        safeEncoders,
        fns,
        path,
        querystring: qs,
        vfile,
        delete: async (fp) =&gt; {
            const f = fp || litLocation.src
            const filepath = f[0] === &#x27;/&#x27; ? f : (&#x27;/&#x27; + f)
            console.log(`Removing local file: &quot;${filepath}&quot;`)
            await lit.fs.unlink(filepath)
            console.log(`Unlinked: &quot;${filepath}&quot;`)
        },
        read: async (fp) =&gt; {
            const f = fp || litLocation.src
            const filepath = f[0] === &#x27;/&#x27; ? f : (&#x27;/&#x27; + f)
            const resp = await lit.fs.readStat(filepath, {encoding: &#x27;utf8&#x27;})
            console.log(`Loaded file: ${filepath} local: ${!!resp.local.stat} remote: ${!!resp.remote.stat} resp: `, resp)

            if (resp.local.stat &amp;&amp; resp.remote.stat) {
                const ageMessage = DatesToRelativeDelta(resp.local.stat.mtimeMs, resp.remote.stat.mtimeMs)
                console.log(`Local file is ${ageMessage} than remote file.`)
            }
        },
    }
}

lit.u = lit.utils

if (typeof window !== &#x27;undefined&#x27;) window.lit = lit

console.log(`lit:`, lit)

time(&#x27;client&#x27;, &#x27;litObj&#x27;)

export const init = async () =&gt; {
    if(lit.location.query.__lit_no_client===&quot;true&quot;) return;

    console.log(&#x27;.lit Notebook client initializing...&#x27;)
    time(&#x27;client&#x27;, &#x27;initStart&#x27;)

    const App = require(&#x27;../components/App&#x27;).default

    const filepath = lit.location.src
    console.log(`Checking local (${lit.location.base}) filesystem for: ${filepath}`)
    let contents, stats;
    let times = {local: null, remote: null}
    try {
        const resp = await lit.fs.readStat(filepath, {encoding: &#x27;utf8&#x27;})
        console.log(`Loaded file: ${filepath} local: ${!!resp.local.stat} remote: ${!!resp.remote.stat} resp: `, resp)
        times.local = resp.local.stat &amp;&amp; MsToRelative(resp.local.stat.mtimeMs - Date.now())
        times.remote = resp.remote.stat &amp;&amp; MsToRelative(resp.remote.stat.mtimeMs - Date.now())

        if (resp.local.stat &amp;&amp; resp.remote.stat) {
            const ageMessage = DatesToRelativeDelta(resp.local.stat.mtimeMs, resp.remote.stat.mtimeMs)
            times.ageMessage = ageMessage
            stats = window.lit.stats = resp
            console.log(`Local file is ${ageMessage} than remote file.`)
        }
        
        contents = resp.local.value || resp.remote.value
    } catch(err) {
        console.error(`Error fetching local and remote file`, err)

        
        if (lit.location.query.template) {
            console.log(`Loading template (${lit.location.query.template}) for 404 file &quot;${lit.location.src}&quot;.`)
            try {
                const template = await lit.fs.readStat(lit.location.query.template, {encoding: &#x27;utf8&#x27;})
                contents = lit.utils.fns.template(template.local.value || template.remote.value, window)
            } catch (err) {
                console.error(`Failed to load template: ${lit.location.query.template}`, err)
            }
        } else if (lit.location.query.title || lit.location.query.body) {
            contents = lit.location.query.title ? `# ${lit.location.query.title}\n\n${lit.location.query.body||&#x27;&#x27;}` : lit.location.query.body || &#x27;&#x27;
        }
        
        console.log(`Showing 404 page`)
        const filename = lit.utils.path.basename(lit.location.src).slice(0, 0-lit.utils.path.extname(lit.location.src).length)
        if (!contents) contents = `# ${lit.location.src}\n\nFile not *yet* found, edit this to change that.`
    }
    time(&#x27;client&#x27;, &#x27;readFile&#x27;)
   
    const file = await vfile({path: filepath, contents})
    file.data = file.data || {}
    file.data.times = times

    window.lit.files = await fetch(lit.location.base + &#x27;compactManifest.json&#x27;)
                          .catch(err=&gt;([]))
                          .then(res =&gt; res.json().then( data =&gt; {
                              return Array.from(lit.utils.compactPrefixTree.getWordsFromTrie(data)).map(x=&gt;&#x27;/&#x27;+x)
                          }))

    window.lit.manifest = await fetch(lit.location.base + &#x27;manifest.json&#x27;)
                            .catch(err=&gt;({}))
                            .then(res =&gt; res.json().then( data =&gt; {
                                return data;
                            }))
    time(&#x27;client&#x27;, &#x27;manifestLoaded&#x27;)
    const processedFile = await renderer.processor({fs,litroot: lit.location.root, files: lit.files}).process(file)
    if (stats) {
        const remoteNewer = stats.local.stat.mtimeMs &lt; stats.remote.stat.mtimeMs
        const hasDiff = stats.local.value !== stats.remote.value
        if (remoteNewer &amp;&amp; hasDiff) {
           const delta = DatesToRelativeDelta(stats.local.stat.mtimeMs, stats.remote.stat.mtimeMs) 
           if (delta !== &#x27;now&#x27;) processedFile.message(`Local file is ${delta} than Remote file. (has Diff)`)
        }
    }

    console.log(&quot;Processed clientside &quot;, file.path)
    window.lit.ast = processedFile.data.ast
    window.lit.file = processedFile

    time(&#x27;client&#x27;, &#x27;processedFile&#x27;)
    try {
        lit.notebook = &lt;App
            root={lit.location.root}
            fs={lit.fs}
            file={processedFile}
            result={processedFile.result}
            files={lit.files}
        /&gt;
    } catch(err) {
        console.error(&quot;Error instantiating App&quot;, err)
    }
    console.log(&#x27;notebook&#x27;, window.lit.notebook)
    
    try {
        ReactDOM.hydrate(window.lit.notebook, document.getElementById(&#x27;lit-app&#x27;))
    } catch (err) {
        console.error(&quot;Error hydrating App&quot;, err)
    }
    time(&#x27;client&#x27;, &#x27;rendered&#x27;)
}

if (typeof WorkerGlobalScope !== &#x27;undefined&#x27;
    &amp;&amp; self instanceof WorkerGlobalScope) {
   // inside worker as lib, don&#x27;t init.
} else {
   init()
}

</code></pre></div></div></div></section>
<div class="footnotes">
<hr/>
<ol>
<li id="fn-1">One lingering exception is transclude. At the very least a link to the file being transcluded should be present, but even this is not <em>yet</em> the case.<a class="footnote-backref" href="#fnref-1">โฉ<span class="linkIcon">ยง</span></a></li>
</ol>
</div></div></div><div id="backlinks"></div><script src="//cdn.jsdelivr.net/npm/eruda"></script><script>eruda.init();</script><script async="" src="/web.bundle.js"></script></body></html>