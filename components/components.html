<html data-reactroot=""><head><title>Components</title><meta name="litsrc" value="/components/components.lit"/><meta name="litroot" value="/"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/><link rel="stylesheet" href="/style.css"/></head><body><div id="lit-app"><div id="lit-header"><menu class="horizontal open has-children"><li class="MenuTitle"><a href="/">Home</a></li><li class="MenuItems"><menu class="has-children" disabled=""><li class="MenuTitle">File</li></menu><menu class="has-children" disabled=""><li class="MenuTitle">Cell</li></menu><menu class="has-children" disabled=""><li class="MenuTitle">Section</li></menu><menu class="has-children" disabled=""><li class="MenuTitle">Help</li></menu><menu class="has-children right"><li class="MenuTitle"><span class="led led-grey"></span><span class="led led-grey"></span><span class="led led-grey"></span></li></menu></li></menu></div><style>body {
  --bg: white;
  --bg-secondary-color: #efefef;
    
  --text-color: black;
  --text-secondary-color: grey;
  --text-primary-color: #9999f7;
  --text-highlight-bg: yellow;
  --text-highlight-color: black;

  --divider-subtle: #efefef;
  --medium-space: 0.4em;
  --code-bg-color: black;
  --code-text-color: white;
  --box-bg-opacity: 0.05;
}</style><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.0.0/build/styles/sunburst.min.css"/><div id="content"><section id="components" depth="1" class="" startpos="3:1-2" endpos="7:21-101"><div startpos="3:1-2" endpos="5:64-79" class="cell"><div class="cell-content"><h1>Components</h1><p>A list of the main components used to render a <code>.lit</code> document.</p></div></div><section id="table-of-contents" depth="2" class="" startpos="7:1-81" endpos="7:21-101"><div startpos="7:1-81" endpos="7:21-101" class="cell"><div class="cell-content"><h2>Table of Contents</h2><ul>
<li>
<p><a class="fragment" href="#document" filepath="/components/components.lit" root="" data="[object Object]" canonical="#document">Document<span class="linkIcon">¬ß</span></a></p>
</li>
<li>
<p><a class="fragment" href="#header" filepath="/components/components.lit" root="" data="[object Object]" canonical="#header">Header<span class="linkIcon">¬ß</span></a></p>
</li>
<li>
<p><a class="fragment" href="#app" filepath="/components/components.lit" root="" data="[object Object]" canonical="#app">App<span class="linkIcon">¬ß</span></a></p>
</li>
<li>
<p><a class="fragment" href="#selection-context" filepath="/components/components.lit" root="" data="[object Object]" canonical="#selection-context">Selection Context<span class="linkIcon">¬ß</span></a></p>
</li>
<li>
<p><a class="fragment" href="#cell" filepath="/components/components.lit" root="" data="[object Object]" canonical="#cell">Cell<span class="linkIcon">¬ß</span></a></p>
<ul>
<li><a class="fragment" href="#cellmenu" filepath="/components/components.lit" root="" data="[object Object]" canonical="#cellmenu">CellMenu<span class="linkIcon">¬ß</span></a></li>
</ul>
</li>
<li>
<p><a class="fragment" href="#editor" filepath="/components/components.lit" root="" data="[object Object]" canonical="#editor">Editor<span class="linkIcon">¬ß</span></a></p>
</li>
<li>
<p><a class="fragment" href="#code" filepath="/components/components.lit" root="" data="[object Object]" canonical="#code">Code<span class="linkIcon">¬ß</span></a></p>
<ul>
<li><a class="fragment" href="#code-meta" filepath="/components/components.lit" root="" data="[object Object]" canonical="#code-meta">Code Meta<span class="linkIcon">¬ß</span></a></li>
<li><a class="fragment" href="#codeblock" filepath="/components/components.lit" root="" data="[object Object]" canonical="#codeblock">Codeblock<span class="linkIcon">¬ß</span></a></li>
</ul>
</li>
<li>
<p><a class="fragment" href="#link" filepath="/components/components.lit" root="" data="[object Object]" canonical="#link">Link<span class="linkIcon">¬ß</span></a></p>
</li>
<li>
<p><a class="fragment" href="#backlinks" filepath="/components/components.lit" root="" data="[object Object]" canonical="#backlinks">Backlinks<span class="linkIcon">¬ß</span></a></p>
</li>
</ul></div></div></section></section>
<section id="document" depth="2" class="" startpos="9:1-103" endpos="13:4-152"><div startpos="9:1-103" endpos="9:12-114" class="cell"><div class="cell-content"><h2>Document</h2></div></div><div startpos="11:1-116" endpos="13:4-152" class="code   cell"><div class="cell-content"><div class="dir-collapse lang-jsx local collapsed codecell"><span class="meta"><span class="lang">jsx</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; Document.jsx</span></span><pre><code class="jsx">import React, {useState} from &#x27;react&#x27;
import path from &#x27;path&#x27;
import App from &#x27;./App&#x27;
import Backlinks from &#x27;./Backlinks&#x27;
import { getConsoleForNamespace } from &#x27;../utils/console&#x27;

const console = getConsoleForNamespace(&#x27;Document&#x27;)

const Document = props =&gt; {

    const files = props.files || []
    const result = props.file.result
    const title = props.file.data.frontmatter.title || props.file.stem
    const theme = props.file.data.frontmatter.theme

    return &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;{title}&lt;/title&gt;
            &lt;meta name=&quot;litsrc&quot; value={props.file.data.canonical}/&gt;
            &lt;meta name=&quot;litroot&quot; value={props.root}/&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0&quot;/&gt;
            {theme &amp;&amp; &lt;link rel=&quot;stylesheet&quot; href={theme}/&gt;}
            &lt;link rel=&quot;stylesheet&quot; href={path.join(props.root, &#x27;style.css&#x27;)}/&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;div id=&quot;lit-app&quot;&gt;&lt;App root={props.root} file={props.file} fs={props.fs} result={result} files={files} ssr={true}/&gt;&lt;/div&gt;
            &lt;div id=&quot;backlinks&quot;&gt;&lt;Backlinks root={props.root} links={props.backlinks || []}/&gt;&lt;/div&gt;
            &lt;script src=&quot;//cdn.jsdelivr.net/npm/eruda&quot;&gt;&lt;/script&gt;
            &lt;script&gt;eruda.init();&lt;/script&gt;
            &lt;script async src={path.join(props.root, &#x27;web.bundle.js&#x27;)}/&gt;
        &lt;/body&gt;
    &lt;/html&gt;
}

export default Document

</code></pre></div></div></div></section>
<section id="header" depth="2" class="" startpos="15:1-154" endpos="19:4-199"><div startpos="15:1-154" endpos="15:10-163" class="cell"><div class="cell-content"><h2>Header</h2></div></div><div startpos="17:1-165" endpos="19:4-199" class="code   cell"><div class="cell-content"><div class="dir-collapse lang-jsx local collapsed codecell"><span class="meta"><span class="lang">jsx</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; Header.jsx</span></span><pre><code class="jsx">import React, { useState, useEffect } from &#x27;react&#x27;
import * as clipboard from &quot;clipboard-polyfill&quot;
import source from &#x27;unist-util-source&#x27;
import SelectionContext from &#x27;./SelectionContext&#x27;
import { Identity } from &#x27;../utils/functions&#x27;
import { getConsoleForNamespace } from &#x27;../utils/console&#x27;
import { CloseIcon } from &#x27;./Icons&#x27;
import { ErrorBoundary } from &#x27;./ErrorBoundry&#x27;
import {version} from &#x27;../../package.json&#x27;

const console = getConsoleForNamespace(&#x27;Header&#x27;)

const setDebug = ev =&gt; {
  ev.preventDefault()
  const key = &#x27;litDebug&#x27;
  const example = &#x27;All,fs,client,Cell,sections,etc...&#x27;
  const storage = typeof localStorage !== &#x27;undefined&#x27; &amp;&amp; localStorage
  const val = prompt(&quot;Set debug mask&quot;, storage.getItem(key) || example)
  storage.setItem( key, val )
  console.log(`Set ${key} to &quot;${val}&quot;`)
  return false
}

const showInspector = ev =&gt; {
  console.log(&#x27;Show mobile inspector&#x27;)
  if (typeof eruda !== &#x27;undefined&#x27; &amp;&amp; eruda) eruda.show()
  else alert(&quot;üö® Eruda console not available&quot;)
}

const LED = ({color,status}) =&gt; {
  return &lt;span title={status} className={`led led-${color}`}&gt;&lt;/span&gt;
}

const useHasMounted = () =&gt; {
  const [hasMounted, setHasMounted] = useState(false);
  useEffect(() =&gt; {
    setHasMounted(true);
  }, []);
  return hasMounted;
}

const Status = ({local, remote, sw, gh}) =&gt; {
  const hasMounted = useHasMounted()
  if (!hasMounted) return &lt;&gt;
      &lt;LED color={&#x27;grey&#x27;} title=&quot;Github&quot; /&gt;
      &lt;LED color={&#x27;grey&#x27;} title=&quot;Service Worker&quot; /&gt;
      &lt;LED color={&#x27;grey&#x27;} title=&quot;Status&quot; /&gt;
    &lt;/&gt;;

  const color = !hasMounted
    ? &#x27;grey&#x27;
    : (local &amp;&amp; !remote)
      ? &#x27;orange&#x27;
      : (remote &amp;&amp; !local) 
        ? &#x27;blue&#x27;
        : (!remote &amp;&amp; !local)
          ? &#x27;red&#x27;
          : &#x27;green&#x27;
  return &lt;&gt;
      &lt;LED color={gh ? &#x27;green&#x27; : &#x27;grey&#x27;} title=&quot;Github&quot; /&gt;
      &lt;LED color={sw ? &#x27;green&#x27; : &#x27;grey&#x27;} title=&quot;Service Worker&quot; /&gt;
      &lt;LED color={color} title=&quot;Status&quot; /&gt;
    &lt;/&gt;
}

const Menu = props =&gt; {
  // console.log(&#x27;&lt;Menu/&gt;&#x27;, props.title,)
  const [open, setOpen] = useState(props.horizontal)
  const toggleOpen = _ =&gt; setOpen(!open)
  const disabled = props.disabled || (!props.onClick &amp;&amp; !props.href &amp;&amp; !props.children)

  const handleClickTitle = ev =&gt; {
    ev.stopPropagation()
    if (disabled) return false

    if (props.onClick) props.onClick()
    else if (props.href) location.href = props.href
    else toggleOpen()
    return false
  }

  const catchClicks = ev =&gt; {
    ev.stopPropagation()
    if (!disabled &amp;&amp; !props.horizontal) {
      toggleOpen()
    }
    return false
  }

  const classes = [
    props.horizontal ? &#x27;horizontal&#x27; : null,
    open ? &#x27;open&#x27; : null,
    props.children ? &#x27;has-children&#x27; : null,
    props.right ? &#x27;right&#x27; : &#x27;&#x27;,
  ].filter(Identity).join(&#x27; &#x27;)

  

  return &lt;menu className={classes} disabled={disabled} onClick={catchClicks}&gt;
    &lt;li className={&quot;MenuTitle&quot;} key=&quot;menu-title&quot; onClick={handleClickTitle}&gt;
      { props.href
        ? &lt;a href={props.href}&gt;{props.title}&lt;/a&gt;
        : props.title }
    &lt;/li&gt;
    { !disabled &amp;&amp; open &amp;&amp; &lt;li className=&quot;MenuItems&quot;&gt;{ props.children }&lt;/li&gt; }
  &lt;/menu&gt;
}

const Message = ({message, setSelectedCell}) =&gt; {
  
  const scroll = ev =&gt; {
    console.log(&#x27;[Message] &#x27;, message)
    setSelectedCell(message.location, true) 
    return false
  }
  const [hide, setHide] = useState(false);
  const dismiss = () =&gt; setHide(true)
  const [showAll, setShowAll] = useState(false)
  const toggleShowAll = ev =&gt; {
    setShowAll(!showAll)
    return false
  }

  const classes = [
    &#x27;lit-message&#x27;,
    showAll &amp;&amp; &#x27;showall&#x27;,
  ].filter(Identity).join(&#x27; &#x27;)

  return hide ? null : &lt;div className={classes}&gt;
    &lt;span className=&quot;message&quot; onClick={toggleShowAll}&gt;{message.message}&lt;/span&gt;
    &lt;span className=&quot;name&quot; onClick={scroll}&gt;
      {message.name.split(&#x27;:&#x27;).slice(1).join(&#x27;:&#x27;)}
    &lt;/span&gt;
    &lt;span className=&quot;close&quot;&gt;&lt;CloseIcon onClick={dismiss}/&gt;&lt;/span&gt;
  &lt;/div&gt;
}

export const Header = ({ root, toggleViewSource, toggleModal}) =&gt; {
  console.log(&#x27;&lt;Header/&gt;&#x27;)

  const hasMounted = useHasMounted();
  const ssr = !hasMounted
  const [sw, setSw] = useState(null);

  const resetFile = (ctx, localOnly) =&gt; async ev =&gt; {
    const filepath = ctx.file.path
    console.log(&quot;Reset File:&quot;, filepath)
    const qualifier = localOnly ? &quot;local&quot; : &quot;local And remote&quot;
    if (confirm(`Are you sure you want to delete the ${qualifier} copy of &quot;${filepath}&quot;`)) {
      await ctx.fs.unlink(filepath, localOnly)
      console.log(&quot;Deleted &quot; + filepath + &quot; reload page&quot;)
      // location.reload()
    }
  }

  const copyToClipboard = ctx =&gt; ev =&gt; {
    clipboard.writeText(ctx.src)
    console.log(&quot;Copied src to clipboard&quot;)
  }

  const ghToken = typeof localStorage !== &#x27;undefined&#x27; &amp;&amp; localStorage.getItem(&#x27;ghToken&#x27;)
  const setGhToken = (ev) =&gt; {
    localStorage.setItem(&#x27;ghToken&#x27;, prompt(&quot;GitHub personal access token&quot;))
  }
  
  const copyCell = ctx =&gt; ev =&gt; {
    const src = source(ctx.selectedCell,ctx.src)
    clipboard.writeText(src)
    console.log(&quot;Copied cell src to clipboard&quot;)
  }
  
  const deleteCell = ctx =&gt; ev =&gt; {
    console.log(&#x27;Deleting cell at pos:&#x27;, ctx.selectedCell)
    ctx.setSrc(ctx.selectedCell, &#x27;&#x27;)
    ctx.selectCell(null)
  }

  const cutCell = ctx =&gt; ev =&gt; {
    console.log(&#x27;Cutting cell at pos:&#x27;, ctx.selectedCell)
    const src = source(ctx.selectedCell,ctx.src)
    clipboard.writeText(src)
    ctx.setSrc(ctx.selectedCell, &#x27;&#x27;)
    ctx.selectCell(null)
  }

  const pasteAfterCell = ctx =&gt; async ev =&gt; {
    console.log(&#x27;Pasting after cell at pos:&#x27;, ctx.selectedCell)
    const src = source(ctx.selectedCell, ctx.src)
    const add = await clipboard.readText()
    ctx.setSrc(ctx.selectedCell, `${src}\n${add}`)
    ctx.selectCell(null)
  }

  const addCodeCell = ctx =&gt; ev =&gt; {
    console.log(&#x27;Adding code cell after cell at pos:&#x27;, ctx.selectedCell)
    const src = source(ctx.selectedCell, ctx.src)
    const add = &quot;```js\n\n```&quot;
    ctx.setSrc(ctx.selectedCell, `${src}\n\n${add}`)
    ctx.selectCell(null)
  }

  const clearCodeCell = ctx =&gt; ev =&gt; {
    console.log(&#x27;Clearing code cell at pos:&#x27;, ctx.selectedCell)
    const meta = source(ctx.selectedCell, ctx.src).split(&#x27;\n&#x27;)[0]
    const end = &#x27;```&#x27;

    ctx.setSrc(ctx.selectedCell, `${meta}\n${end}`)
  }

  useEffect(async () =&gt; {
    const resp = await fetch(&#x27;--sw&#x27;).then( res =&gt; res.json().catch( err=&gt; null) ).catch(err =&gt; null)
    setSw(resp)
  }, [])

  return &lt;SelectionContext.Consumer&gt;{(ctx) =&gt; {

    const cellSelected = (ctx.selectedCell &amp;&amp; ctx.selectedCell.start) || false

    const local = ctx.file &amp;&amp; ctx.file.data &amp;&amp; ctx.file.data.times &amp;&amp; ctx.file.data.times.local
    const remote = ctx.file &amp;&amp; ctx.file.data &amp;&amp; ctx.file.data.times &amp;&amp; ctx.file.data.times.remote
    const ageMessage = ctx.file &amp;&amp; ctx.file.data &amp;&amp; ctx.file.data.times &amp;&amp; ctx.file.data.times.ageMessage

      
    const menuPlugins = !ssr &amp;&amp; ctx?.file?.data?.plugins?.menu
    const fileMenuPlugins = !ssr &amp;&amp; ctx?.file?.data?.plugins?.[&quot;filemenu&quot;]
    const cellMenuPlugins = !ssr &amp;&amp; ctx?.file?.data?.plugins?.[&quot;cellmenu&quot;]
    const sectionMenuPlugins = !ssr &amp;&amp; ctx?.file?.data?.plugins?.[&quot;sectionmenu&quot;]
    const helpMenuPlugins = !ssr &amp;&amp; ctx?.file?.data?.plugins?.[&quot;helpmenu&quot;]

    console.log(&#x27;&lt;Header/&gt; plugins?&#x27;, menuPlugins)

    return &lt;div id=&quot;lit-header&quot;&gt;
    &lt;Menu title=&quot;Home&quot; horizontal href={root}&gt;
      &lt;Menu title=&quot;File&quot; disabled={ssr}&gt;
        &lt;span disabled className=&quot;meta&quot;&gt;{ageMessage}&lt;/span&gt;
        &lt;span disabled&gt;New&lt;/span&gt;
        &lt;span disabled&gt;Open&lt;/span&gt;
        &lt;span disabled&gt;Save&lt;/span&gt;
        &lt;span onClick={toggleViewSource}&gt;View Source&lt;/span&gt;
        &lt;span onClick={copyToClipboard(ctx)}&gt;Copy&lt;/span&gt;
        &lt;span onClick={resetFile(ctx, true)}&gt;Reset&lt;/span&gt;
        &lt;span onClick={resetFile(ctx)}&gt;Delete&lt;/span&gt;

        { !fileMenuPlugins ? null : fileMenuPlugins &amp;&amp; Object.keys(fileMenuPlugins).map( key =&gt; &lt;ErrorBoundary&gt;{fileMenuPlugins[key](ctx, {React, Menu, toggleModal})}&lt;/ErrorBoundary&gt;) }

      &lt;/Menu&gt;
      &lt;Menu title=&quot;Cell&quot; disabled={!cellSelected}&gt;
        &lt;span disabled className=&quot;meta&quot;&gt;
          {cellSelected &amp;&amp; `Lines ${ctx.selectedCell.start.line}-${ctx.selectedCell.end.line}`}
        &lt;/span&gt;
        &lt;span disabled={!cellSelected} onClick={addCodeCell(ctx)}&gt;Add Code&lt;/span&gt;
        &lt;span disabled={!cellSelected} onClick={deleteCell(ctx)}&gt;Remove&lt;/span&gt;
        &lt;span disabled={!cellSelected} onClick={clearCodeCell(ctx)}&gt;Empty Code&lt;/span&gt;
        &lt;span disabled&gt;Edit&lt;/span&gt;
        &lt;span disabled&gt;Execute&lt;/span&gt;
        &lt;Menu title=&quot;Move&quot; disabled={!cellSelected}&gt;
          &lt;span disabled&gt;Up&lt;/span&gt;
          &lt;span disabled&gt;Down&lt;/span&gt;
        &lt;/Menu&gt;
        &lt;span disabled={!cellSelected} onClick={copyCell(ctx)}&gt;Copy&lt;/span&gt;
        &lt;span disabled={!cellSelected} onClick={cutCell(ctx)}&gt;Cut&lt;/span&gt;
        &lt;span disabled={!cellSelected} onClick={pasteAfterCell(ctx)}&gt;Paste After&lt;/span&gt;

        { !cellMenuPlugins ? null : cellMenuPlugins &amp;&amp; Object.keys(cellMenuPlugins).map( key =&gt; &lt;ErrorBoundary&gt;{cellMenuPlugins[key](ctx, {React, Menu , toggleModal})}&lt;/ErrorBoundary&gt;) }
      &lt;/Menu&gt;
      &lt;Menu title=&quot;Section&quot; disabled={!cellSelected}&gt;
        &lt;span disabled&gt;Collapse&lt;/span&gt;
        &lt;span disabled&gt;Remove&lt;/span&gt;
        &lt;Menu title=&quot;Move&quot;&gt;
          &lt;span disabled&gt;Up&lt;/span&gt;
          &lt;span disabled&gt;Down&lt;/span&gt;
        &lt;/Menu&gt;

        { !sectionMenuPlugins ? null : sectionMenuPlugins &amp;&amp; Object.keys(sectionMenuPlugins).map( key =&gt; &lt;ErrorBoundary&gt;{sectionMenuPlugins[key](ctx, {React, Menu, toggleModal})}&lt;/ErrorBoundary&gt;) }

      &lt;/Menu&gt;
      
      { !menuPlugins ? null : menuPlugins &amp;&amp; Object.keys(menuPlugins).map( key =&gt; &lt;ErrorBoundary&gt;{menuPlugins[key](ctx, {React, Menu, toggleModal})}&lt;/ErrorBoundary&gt;) }
      
      &lt;Menu title=&quot;Help&quot; disabled={ssr}&gt;
        { !helpMenuPlugins ? null : helpMenuPlugins &amp;&amp; Object.keys(helpMenuPlugins).map( key =&gt; &lt;ErrorBoundary&gt;{helpMenuPlugins[key](ctx, {React, Menu, toggleModal})}&lt;/ErrorBoundary&gt;) }
        &lt;a href=&quot;/config.html?file=config.lit&quot;&gt;Config&lt;/a&gt;
        &lt;Menu title=&quot;Debug&quot;&gt;
            &lt;span onClick={setDebug}&gt;Set Mask&lt;/span&gt;
            &lt;span onClick={showInspector}&gt;Show Inspector&lt;/span&gt;
        &lt;/Menu&gt;
      &lt;/Menu&gt;
      &lt;Menu right title={&lt;Status local={local} remote={remote} sw={sw} gh={ctx?.fs?.ghOrigin}/&gt;}&gt;
        &lt;span disabled&gt;{`GitHub: ${ ctx?.fs?.ghOrigin ? &#x27;Connected&#x27; : &#x27;Not connected&#x27;}`}&lt;/span&gt;
        &lt;span disabled&gt;{`Service Worker: ${ sw ? sw.version : &#x27; not&#x27;} active.`}&lt;/span&gt;
        {ctx.file &amp;&amp; &lt;span disabled&gt;{`File: ${ctx.file.path}`}&lt;/span&gt;}
        {local &amp;&amp; &lt;span disabled&gt;{`Local last updated ${local}`}&lt;/span&gt; }
        {remote &amp;&amp; &lt;span disabled&gt;{`Remote last updated ${remote}`}&lt;/span&gt; }
        {ageMessage &amp;&amp; &lt;span disabled&gt;{`Local is ${ageMessage} than remote.`}&lt;/span&gt; }
        {cellSelected &amp;&amp; &lt;span disabled&gt;{`Lines ${ctx.selectedCell.start.line}-${ctx.selectedCell.end.line}`}&lt;/span&gt; }
      &lt;/Menu&gt;
    &lt;/Menu&gt;
    {!ssr &amp;&amp; &lt;div className=&quot;lit-messages&quot;&gt;
    { ctx.file.messages.map( m =&gt; {
        return &lt;Message key={m.name} message={m} setSelectedCell={ctx.setSelectedCell} /&gt;
    } ) }
    &lt;/div&gt; }
  &lt;/div&gt;
  }}
&lt;/SelectionContext.Consumer&gt;
}

</code></pre></div></div></div></section>
<section id="app" depth="2" class="" startpos="20:1-200" endpos="24:4-239"><div startpos="20:1-200" endpos="20:7-206" class="cell"><div class="cell-content"><h2>App</h2></div></div><div startpos="22:1-208" endpos="24:4-239" class="code   cell"><div class="cell-content"><div class="dir-collapse lang-jsx local collapsed codecell"><span class="meta"><span class="lang">jsx</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; App.jsx</span></span><pre><code class="jsx">import React, {useState, useEffect} from &#x27;react&#x27;
import path from &#x27;path&#x27;
import SelectionContext from &#x27;./SelectionContext&#x27;
import { Header } from &#x27;./Header&#x27;
import Editor from &#x27;./Editor&#x27;
import Highlight from &#x27;react-highlight.js&#x27;
import source from &#x27;unist-util-source&#x27;
import patchSource from &#x27;../utils/unist-util-patch-source&#x27;
import { processor } from &#x27;../renderer&#x27;
import {utils as parserUtils} from &#x27;../parser&#x27;
import { getConsoleForNamespace } from &#x27;../utils/console&#x27;
import filter from &#x27;unist-util-filter&#x27;
import { atPos } from &#x27;../utils/unist-util-select-position&#x27;
import { selectAll } from &#x27;unist-util-select&#x27;
import { posstr } from &#x27;../utils/functions&#x27;
import { ErrorBoundary } from &#x27;./ErrorBoundry&#x27;

const console = getConsoleForNamespace(&#x27;App&#x27;)

const {toMarkdown, ungroupSections} = parserUtils

const ONLOAD = &quot;onload&quot;
const ONSAVE = &quot;onsave&quot;
const ONSELECT = &quot;onselect&quot;

const onLifecyclePlugins = async (file, type, ...args) =&gt; {
    const plugins = file?.data?.plugins?.[type] || {}
    const keys = Object.keys(plugins)
    console.log(`[${type}] plugins: ${keys.length}`)
    for (const key of keys) {
        if (typeof plugins[key] === &#x27;function&#x27;) {
            await plugins[key](...args)
        }
    }
}

const ast2md = (ast) =&gt; {
  const unGroup = ungroupSections()()
  const tree = unGroup(ast)
  const md = toMarkdown(tree)
  return md
}

const App = ({root, file, fs, result, files, ssr}) =&gt; {

    const [srcAndRes, setSrcAndRes] = useState({
        src: file.contents.toString(),
        res: result
    })

    const [res, setResult] = useState(result)
    const [selectedCell, setSelectedCell] = useState(null)
    
    const [viewSource, setViewSource] = useState(false)
    const toggleViewSource = () =&gt; setViewSource(!viewSource)

    const [modal, setModal] = useState(false)
    const toggleModal = (val) =&gt; setModal(val)


    const themePlugins = file?.data?.plugins?.theme
    const themes = themePlugins &amp;&amp; Object.keys(themePlugins).map(t=&gt;({id: t, ...themePlugins[t]}))
    
    const setSrcWrapper = async (pos, cellSource) =&gt; {
        console.log(&quot;&lt;App/&gt; Set src wrapper&quot;, posstr(pos))
        const patchedSrc = patchSource(srcAndRes.src, pos, cellSource.trimEnd())
        if (patchedSrc === srcAndRes.src) {
            console.log(&quot;No Change to source of document. Not updating.&quot;)
            return;
        }
        
        file.contents = patchedSrc
        file.messages = []
        const processedFile = await processor({fs, files}).process(file)
        console.log(&quot;Processed clientside on setSrc&quot;, file.path)

        await onLifecyclePlugins(processedFile, ONSAVE, patchedSrc, processedFile, processedFile.data.ast)

        if (typeof window !== &#x27;undefined&#x27;) {
            window.lit.file = processedFile
            window.lit.ast = processedFile.data.ast
        }
      
        try {
            await fs.writeFile(file.path, patchedSrc, {encoding: &#x27;utf8&#x27;})
        } catch (err) {
            console.log(&quot;Failed to write file source to fs&quot;, file.path, err)
        }
        
        const tmpEnd = {line: pos.start.line + cellSource.split(&#x27;\n&#x27;).length }
        const tmpPos = {start: pos.start, end: tmpEnd }
        const tree = filter(processedFile.data.ast, atPos(tmpPos))
        const nodes = selectAll(&#x27;code&#x27;, tree)
        console.log(&quot;[CodeCells in Change (pos)]&quot;, tmpPos, file.path, tree, nodes)
        for (const codeCell of nodes) {
            const meta = codeCell.data &amp;&amp; codeCell.data.meta &amp;&amp; codeCell.data.meta
            const filename = meta &amp;&amp; (meta.filename) //|| meta.source?.filename)
            const extract = filename &amp;&amp; (meta.isOutput) &amp;&amp; meta.extract !== &#x27;false&#x27;
            const content = source(codeCell.position, patchedSrc).split(&#x27;\n&#x27;).slice(1,-1).join(&#x27;\n&#x27;)
            if (extract) {
                const filepath = path.join( path.dirname(file.path), filename)
                await fs.writeFile(filepath, content)
                console.log(`Wrote codefile ${filename} to &quot;${filepath}&quot; on disk`)
            }
       }

       setSrcAndRes({
            src: patchedSrc,
            res: processedFile.result
       })
       setSelectedCell(tmpPos)
    }

    const setSelectedCellWrapper = async (pos, scroll) =&gt; {
        console.log(&quot;Selected Cell:&quot;, pos)
        await onLifecyclePlugins(window.lit.file, ONSELECT, pos, scroll)
        setSelectedCell(pos)
        if (pos &amp;&amp; scroll) {
            document.querySelector(`[startpos=&quot;${posstr(pos.start)}&quot;]`).scrollIntoViewIfNeeded()
        }
    }

    const state = {
        fs: fs,
        file: file,  
        src: srcAndRes.src, 
        selectedCell, 
        setSelectedCell: setSelectedCellWrapper, 
        setSrc: setSrcWrapper,
        ast2md,
    }

    useEffect( async fn =&gt; {
       await onLifecyclePlugins(file, ONLOAD, state)
    },[])

    console.log(`Render &quot;${file.path}&quot; (selected: ${selectedCell} `)

    return &lt;SelectionContext.Provider value={state}&gt;
        &lt;ErrorBoundary&gt;{ &lt;Header root={root} toggleViewSource={toggleViewSource} toggleModal={toggleModal} ssr={ssr}/&gt; }&lt;/ErrorBoundary&gt;
        {themes &amp;&amp; themes.map( theme =&gt; {
           return theme.url 
               ? &lt;link key={theme.id} rel=&quot;stylesheet&quot; href={theme.url}/&gt;
               : &lt;style key={theme.id} dangerouslySetInnerHTML={{__html: theme.value}}&gt;&lt;/style&gt;
        })}
        &lt;div id=&quot;content&quot;&gt;
          { modal
            ? &lt;ErrorBoundary&gt;{modal}&lt;/ErrorBoundary&gt;
            : viewSource 
              ? &lt;ErrorBoundary&gt;&lt;Highlight language=&quot;md&quot;&gt;{srcAndRes.src}&lt;/Highlight&gt;&lt;/ErrorBoundary&gt;
              : &lt;ErrorBoundary&gt;{srcAndRes.res}&lt;/ErrorBoundary&gt; }
        &lt;/div&gt;
    &lt;/SelectionContext.Provider&gt;
}

export default App

</code></pre></div></div></div></section>
<section id="" depth="2" class="" startpos="25:1-240" endpos="25:4-243"><div startpos="25:1-240" endpos="25:4-243" class="cell"><div class="cell-content"><h2></h2></div></div></section>
<section id="selection-context" depth="2" class="" startpos="28:1-246" endpos="32:4-312"><div startpos="28:1-246" endpos="28:21-266" class="cell"><div class="cell-content"><h2>Selection Context</h2></div></div><div startpos="30:1-268" endpos="32:4-312" class="code   cell"><div class="cell-content"><div class="dir-collapse lang-jsx local collapsed codecell"><span class="meta"><span class="lang">jsx</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; SelectionContext.jsx</span></span><pre><code class="jsx">import React from &#x27;react&#x27;

// SelectedCell is the hast node corresponding to the cell.

export default React.createContext({
    fs: {},
    file: {},
    src: &#x27;&#x27;,
    selectedCell: null,
    setSelectedCell: ()=&gt;{},
    setSrc: () =&gt; {},
});

</code></pre></div></div></div></section>
<section id="cell" depth="2" class="" startpos="33:1-313" endpos="43:4-406"><div startpos="33:1-313" endpos="33:8-320" class="cell"><div class="cell-content"><h2>Cell</h2></div></div><div startpos="35:1-322" endpos="37:4-354" class="code   cell"><div class="cell-content"><div class="dir-collapse lang-jsx local collapsed codecell"><span class="meta"><span class="lang">jsx</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; Cell.jsx</span></span><pre><code class="jsx">import React, {useState,useEffect} from &quot;react&quot;
import vfile from &#x27;vfile&#x27;
import path from &#x27;path&#x27;
import source from &#x27;unist-util-source&#x27;
import filter from &#x27;unist-util-filter&#x27;
import { atPos } from &#x27;../utils/unist-util-select-position&#x27;
import { selectAll } from &#x27;unist-util-select&#x27;

import CellMenu from &#x27;./CellMenu&#x27;
import SelectionContext from &#x27;./SelectionContext&#x27;
import Editor from &#x27;./Editor&#x27;
import {Repl} from &#x27;../repl&#x27;
import {processor} from &#x27;../renderer&#x27;

import { getConsoleForNamespace } from &#x27;../utils/console&#x27;
import { posstr } from &#x27;../utils/functions&#x27;

const console = getConsoleForNamespace(&#x27;Cell&#x27;)

const childIs = (node, nodeType) =&gt; (node &amp;&amp; node.children 
    &amp;&amp; node.children.length
    &amp;&amp; node.children[0] 
    &amp;&amp; node.children[0].tagName === nodeType) ? node.children[0] : null



const Cell = props =&gt; {

    const node = props.node
    node.position = node.position || {}
    const pos = node.position

    const [src, setSrc] = useState(&#x27;&#x27;)
    const [content, setContent] = useState(null)
    const [loaded, setLoaded] = useState(null)
    // const content = props.children
    const [editing, setEditing] = useState(false)
    const [executing, setExecuting] = useState(false)
    const toggleEditing = () =&gt; setEditing(!editing)
    
    const isSelected = ctx =&gt; {
        return ctx.selectedCell
            &amp;&amp; ctx.selectedCell.start &amp;&amp; ctx.selectedCell.end
            &amp;&amp; atPos(ctx.selectedCell)(node)
            // &amp;&amp; ctx.selectedCell.start.line === pos.start.line
            // &amp;&amp; ctx.selectedCell.end.line === pos.end.line
    }
    const toggleSelected = ctx =&gt; () =&gt; {
        const selected = isSelected(ctx)
        console.log(`Toggle selected (was ${selected})`, ctx.selectedCell)
        ctx.setSelectedCell(selected ? null : pos)
    }
    

    const isCodeCell = childIs(props.node, &#x27;pre&#x27;)
    const codeNode = childIs(isCodeCell, &#x27;code&#x27;);
    const meta = codeNode ? codeNode.properties.meta : null
    const codeSource = codeNode &amp;&amp; codeNode.data &amp;&amp; codeNode.data.value
    const rawSource = codeSource &amp;&amp; (&quot;```&quot; + (meta.raw || &#x27;&#x27;) + &quot;\n&quot; + codeSource + &quot;```&quot;)

    const isTranscluded = meta?.source?.filename
    const originalSource = meta &amp;&amp; (&quot;```&quot; + (meta.raw || &#x27;&#x27;) + &quot;\n&quot; + (isTranscluded ? (codeNode.data.originalSource||&quot;&quot;) : codeNode.data.value) + &quot;```&quot;)
    
    const output = meta &amp;&amp; meta.isOutput

   

    const save = ctx =&gt; async args =&gt; {
        console.log(&quot;Saving cell&quot;, pos)
        const transform = meta &amp;&amp; (meta.transformer || meta.lang)
        const transformer = lit.file?.data?.plugins?.transformer?.[transform]
        if (transformer) {
            console.log(&quot;Transforming on save:&quot;, transformer)
            const newSrc = await transformer({node, src, codeSource, rawSource, originalSource})
            ctx.setSrc(pos, newSrc)
        } else {
            ctx.setSrc(pos, src)
        }
        setEditing(false)
    }

    const exec = ctx =&gt; async args =&gt; {
        console.log(&#x27;Executing cell&#x27;, {pos, codeSource, rawSource, originalSource})
        setExecuting(true)
        const repl = meta.repl ? meta.repl : meta.lang
        let result
        let error
        if (lit?.file?.data?.plugins?.repl?.[repl]) {
            try { 
                 result = {stdout: await lit.file.data.plugins.repl[repl](codeSource, meta, node) } 
             } catch(err) { 
                 console.error(&quot;REPL plugin error&quot;, err)
                 error = true 
                 result = err
             }
        } else {
        try {
            const repl = new Repl()
            result = await repl.exec(codeSource, meta, node)
        } catch(res) {
            error = true
            console.log(&#x27;REPL promise rejected&#x27;, res)
            result = res
        }
        }
        console.log(&#x27;Execution result&#x27;, result)
        setExecuting(false)
        if (result &amp;&amp; meta.react &amp;&amp; result.resp &amp;&amp; React.isValidElement(result.resp))
            setContent(result.resp)
        else if (result &amp;&amp; meta.selfmutate &amp;&amp; typeof result.resp === &quot;string&quot;) {
            console.log(&quot;Experimental!! Special setSrc as cell is self mutating&quot;)
            // assumes source has changed in the filesystem 
            // so re-render from that
            if (ctx) ctx.setSrc(lit.ast.position, result.resp)
        } else {
            const outputMeta = (meta.hasOutput ? meta.output.raw : &#x27;txt&#x27;).trim() + (&quot; attached=true updated=&quot; + Date.now()) + (error ? &#x27; !error&#x27; : &#x27;&#x27;)
            let output
            if (ctx &amp;&amp; meta?.output?.filename) {
                const filepath = path.join( path.dirname(ctx.file.path), meta.output.filename)
                console.log(&quot;Write repl output to file system &quot;, filepath, result.stdout)
                lit.fs.writeFile( filepath, result.stdout)
                output = &quot;\n```&gt;&quot;+ outputMeta.replace(meta.output.filename,&#x27;&#x27;) + &quot; &lt; &quot; + meta.output.filename + &quot;\n\n```\n&quot;
            } else {
                output = &quot;\n```&gt;&quot;+ outputMeta + &quot;\n&quot; + result.stdout.replace(/\n```/g, &quot;\n‚Ä¢‚Ä¢‚Ä¢&quot;) + &quot;\n```\n&quot;
            }
           
           
            const src = isTranscluded ? originalSource : rawSource
            console.log(&quot;exec setSrc&quot;, !!ctx, pos, src + output)
            if (ctx) ctx.setSrc(pos, src + output)
            else return src + output
        }
    }

    useEffect( async () =&gt; {
         if (!loaded &amp;&amp; meta &amp;&amp; meta.exec === &#x27;onload&#x27;) {
             let result
             try {
             console.log(&quot;Onload execution: &quot;, rawSource)
             const output = await exec()()
             console.log(&quot;produced output&quot;, output)
             const outputVFile = await vfile({ path: meta.output?.filename || lit.location.src, contents: output})
             result = await processor({fs: lit.fs,litroot: lit.location.root}).process(outputVFile)
             console.log(&quot;Result&quot;, result)
             setLoaded(true)
             } catch(err) {
               console.error(&quot;onload exec failed&quot;, err.message, err.stack)
               return
             }
             setContent(result.result.props.children[0].props.children) // Whoa! That is a DirtyHack‚Ñ¢Ô∏è; result.result is a cell so will nest infinitely 
         }
    },[])

    const getClasses = ctx =&gt; [
        isSelected(ctx) ? &#x27;selected&#x27; : &#x27;&#x27;,
        editing ? &#x27;editing&#x27; : &#x27;&#x27;,
        isCodeCell ? &#x27;code&#x27; : &#x27;&#x27;,
        output ? &#x27;output&#x27; : &#x27;&#x27;,
        executing ? &#x27;executing&#x27; :&#x27;&#x27;,
        &#x27;cell&#x27;
    ].join(&#x27; &#x27;).trim() || undefined

    const editCell = (src) =&gt; isCodeCell 
        ? &lt;div className=&quot;codeCellEditor&quot;&gt;
              &lt;Editor src={src} update={setSrc}/&gt; 
          &lt;/div&gt;
        : &lt;Editor src={src} update={setSrc}/&gt; 

    return &lt;SelectionContext.Consumer&gt;
        { ctx =&gt; {
            const src = rawSource || source(pos, ctx.src)
            return &lt;div
                onClick={toggleSelected(ctx)}
                startpos={posstr(pos.start)}
                endpos={posstr(pos.end)}
                className={getClasses(ctx)}&gt;
                    { editing ? editCell(src) : &lt;div className=&quot;cell-content&quot;&gt;{content || props.children}&lt;/div&gt; }
                    { isSelected(ctx) &amp;&amp; &lt;CellMenu meta={meta} editing={editing} toggleEditing={toggleEditing} save={save(ctx)} exec={exec(ctx)}/&gt;}
            &lt;/div&gt;
        }}
    &lt;/SelectionContext.Consumer&gt;
}

export default Cell

</code></pre></div></div></div><section id="cellmenu" depth="3" class="" startpos="39:1-356" endpos="43:4-406"><div startpos="39:1-356" endpos="39:13-368" class="cell"><div class="cell-content"><h3>CellMenu</h3></div></div><div startpos="41:1-370" endpos="43:4-406" class="code   cell"><div class="cell-content"><div class="dir-collapse lang-jsx local collapsed codecell"><span class="meta"><span class="lang">jsx</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; CellMenu.jsx</span></span><pre><code class="jsx">import React, {useState} from &quot;react&quot;
import { MenuIcon, EditIcon, ExecIcon, CloseIcon, SaveIcon, TrashIcon, CancelUndoIcon } from &#x27;./Icons&#x27;
import { getConsoleForNamespace } from &#x27;../utils/console&#x27;

const console = getConsoleForNamespace(&#x27;CellMenu&#x27;)

const wrapHandler = fn =&gt; ev =&gt; {
    console.log(&quot;Cell menu wrapper&quot;, fn, ev)
    ev.preventDefault()
    ev.stopPropagation()
    if (typeof fn === &#x27;function&#x27;){
        const resp = fn(ev)
        console.log(&quot;Cell menu wrapper fn executed&quot;, resp)
    }
    return false
}


const CellMenuItem = ({title, icon, handler}) =&gt; {
    const Icon = icon
    const onClick = handler ? wrapHandler(handler) : null
    return &lt;li title={title} key={title} onClick={onClick}&gt;{&lt;Icon/&gt;}&lt;/li&gt;
}

const isExecutable = (meta) =&gt; {
    return meta &amp;&amp; (meta.repl || meta.lang === &#x27;js&#x27;)
}

const CellMenu = ({meta, editing, toggleEditing, save, exec} = {}) =&gt; {

    const [open, setOpen] = useState(false)
    const toggleOpen = wrapHandler(ev =&gt; {
        console.log(&quot;Toggle CellMenu&quot;, open)
        setOpen(!open)
    })

    return &lt;menu&gt;
        &lt;ul className=&quot;menu__items&quot;&gt;
            { open &amp;&amp; isExecutable(meta) &amp;&amp; &lt;CellMenuItem title=&quot;Execute&quot; icon={ExecIcon} handler={exec}/&gt;}
            { open &amp;&amp; !editing &amp;&amp; &lt;CellMenuItem title=&quot;Edit&quot; icon={EditIcon} handler={toggleEditing}/&gt;}
            { open &amp;&amp; editing &amp;&amp; &lt;CellMenuItem title=&quot;Cancel&quot; icon={CancelUndoIcon} handler={toggleEditing}/&gt;}
            { open &amp;&amp; editing &amp;&amp; &lt;CellMenuItem title=&quot;Save&quot; icon={SaveIcon} handler={save}/&gt;}
            { !open 
                ? &lt;CellMenuItem title=&quot;Open&quot; icon={MenuIcon} handler={toggleOpen} /&gt;
                : &lt;CellMenuItem title=&quot;Close&quot; icon={CloseIcon} handler={toggleOpen} /&gt; }
        &lt;/ul&gt;
    &lt;/menu&gt;
}

export default CellMenu

</code></pre></div></div></div></section></section>
<section id="editor" depth="2" class="" startpos="44:1-407" endpos="48:4-452"><div startpos="44:1-407" endpos="44:10-416" class="cell"><div class="cell-content"><h2>Editor</h2></div></div><div startpos="46:1-418" endpos="48:4-452" class="code   cell"><div class="cell-content"><div class="dir-collapse lang-jsx local collapsed codecell"><span class="meta"><span class="lang">jsx</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; Editor.jsx</span></span><pre><code class="jsx">import React from &#x27;react&#x27;
import {EditorState, EditorView, basicSetup} from &quot;@codemirror/basic-setup&quot;
import {Compartment} from &#x27;@codemirror/state&#x27;
import {autocompletion} from &quot;@codemirror/autocomplete&quot;

// import {html} from &quot;@codemirror/lang-html&quot;
// import {oneDark} from &quot;@codemirror/theme-one-dark&quot;

//import {esLint} from &quot;@codemirror/lang-javascript&quot;
// @ts-ignore
//import Linter from &quot;eslint4b-prebuilt&quot;
//import {linter} from &quot;@codemirror/lint&quot;

//import {StreamLanguage} from &quot;@codemirror/stream-parser&quot;
//import {javascript} from &quot;@codemirror/legacy-modes/mode/javascript&quot;

const lineWrapping = new Compartment

export default class Editor extends React.Component {
    constructor(props) {
        super(props)
        const {src, update} = props;
        this.editorRef = React.createRef();

        const linkOptions = lit.manifest.nodes.filter(n=&gt;(n.exists &amp;&amp; (n.id.endsWith(&#x27;.lit&#x27;) || n.id.endsWith(&#x27;.md&#x27;)))).map( n =&gt; {
            const id = n.id.slice(1).replace(/\.lit|\.md$/, &#x27;&#x27;)
            return {
                label: &#x27;[[&#x27; + id + &#x27;]]&#x27; , 
                type: &#x27;link&#x27;, 
                detail: n.title,
                apply: &#x27;[[&#x27; + id + &#x27;|&#x27; + n.title
            }
        })

        this.editorState = window.cms = EditorState.create({
            doc: props.src, 
            extensions: [
                basicSetup,
                EditorView.lineWrapping,
                EditorView.updateListener.of(this.onUpdate.bind(this)),
                autocompletion({
                    override: [function (context) {
                        let word = context.matchBefore(/\S*/)
                        console.log(word, context)
                        if(word.from == word.to &amp;&amp; !context.explicit) return null
                        if (word.text.startsWith(&#x27;[[&#x27;)) {
                            return {
                                from: word.from,
                                options: [
                                    // types: class, constant, enum, function, interface, keyword, method, namespace, property, text, type, and variable
                                    ...linkOptions
                                ]
                            }
                        }
                        return {
                            from: word.from,
                            options: [
                                {label: &quot;toc&quot;, type: &quot;keyword&quot;, detail:&quot;Table of contents&quot;, apply: &quot;Table of contents&quot;},
                                {label: &quot;`&quot;, type: &quot;variable&quot;, detail: &quot;Fenced code block&quot;, apply:&quot;```\n\n```&quot;},
                                {label: &quot;magic&quot;, type: &quot;text&quot;, apply: &quot;‚†Å‚≠í*.‚ú©.*‚≠í‚†Å&quot;, detail: &quot;macro&quot;}
                            ]
                        }
                    }],
                    activateOnTyping: true,
                }),
                //   html(),
                //   oneDark
                //  linter(esLint(new Linter)),
                //  StreamLanguage.define(javascript),
            ]
        })
    }

    onUpdate(viewUpdate) {
        if (this.props.update &amp;&amp; typeof this.props.update === &#x27;function&#x27;) {
            this.props.update(viewUpdate.state.doc.toString())
        }
    }

    componentDidMount() {
        this.view = window.cmv = new EditorView({
            state: this.editorState, 
            parent: this.editorRef.current
        })
    }
    render() {
        return &lt;div className=&quot;editor&quot; ref={this.editorRef}&gt;&lt;/div&gt;
    }
}

</code></pre></div></div></div></section>
<section id="code" depth="2" class="" startpos="52:1-456" endpos="58:4-516"><div startpos="52:1-456" endpos="52:8-463" class="cell"><div class="cell-content"><h2>Code</h2></div></div><section id="code-meta" depth="3" class="" startpos="54:1-465" endpos="58:4-516"><div startpos="54:1-465" endpos="54:14-478" class="cell"><div class="cell-content"><h3>Code Meta</h3></div></div><div startpos="56:1-480" endpos="58:4-516" class="code   cell"><div class="cell-content"><div class="dir-collapse lang-jsx local collapsed codecell"><span class="meta"><span class="lang">jsx</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; CodeMeta.jsx</span></span><pre><code class="jsx">import React from &#x27;react&#x27;
import {Time} from &#x27;./Time&#x27;
import { stringToHex, pickTextColorBasedOnBgColor } from &#x27;../utils/colors&#x27;

const colorStyle = (val) =&gt; {
    let bgColor = stringToHex(val)
    let textColor = pickTextColorBasedOnBgColor(bgColor, &#x27;white&#x27;, &#x27;black&#x27;)

    // Custom exceptions
    if (val === &#x27;error&#x27;)  {
        bgColor = &#x27;red&#x27;,
        textColor = &#x27;white&#x27;
    }

    return {
        color: textColor,
        backgroundColor: bgColor
    }
}

export const CodeMeta = ({meta, toggleFullscreen, toggleLocalRemote, toggleCollapsed}) =&gt; {

        return &lt;span className=&quot;meta&quot;&gt;
            &lt;span className=&quot;lang&quot; onClick={toggleCollapsed}&gt;{meta.lang}&lt;/span&gt;
            {meta.repl &amp;&amp; &lt;span className=&quot;repl&quot;&gt;{meta.repl}&lt;/span&gt; }
            {meta.filename &amp;&amp; &lt;span className=&quot;filename&quot;&gt;{meta.filename}&lt;/span&gt;}
            {meta.directives &amp;&amp; meta.directives.map( (dir, i) =&gt; {
                const onClick = dir === &#x27;inline&#x27; ? toggleFullscreen : null
                return &lt;span key={dir} onClick={onClick} style={colorStyle(dir)} className={`directive dir-${dir}`}&gt;{dir}&lt;/span&gt;
            })}
            { meta.attrs &amp;&amp; Object.keys(meta.attrs).map(attr =&gt; {
                const val = meta.attrs[attr]
                // ignored attributes for display
                if(val===true || val===&quot;true&quot; || attr===&quot;updated&quot; || attr===&quot;repl&quot;) return null
                return &lt;span className={`attribute attr-${attr}`} key={attr} style={colorStyle(attr)}&gt;{`${attr}=${val}`}&lt;/span&gt;
            })}
            {meta.tags &amp;&amp; meta.tags.map( (tag, i) =&gt; &lt;span key={tag+i} style={colorStyle(tag)} className=&quot;tag&quot;&gt;{tag}&lt;/span&gt;)}
            {meta.fromSource &amp;&amp; &lt;span onClick={toggleLocalRemote} className=&quot;source&quot;&gt;{&#x27;&lt; &#x27; + meta.fromSource }&lt;/span&gt; }
            {meta.hasOutput &amp;&amp; &lt;span className=&quot;output&quot;&gt;{&#x27;&gt; &#x27; + meta.output.raw}&lt;/span&gt; }
            {meta.updated &amp;&amp; &lt;span className=&quot;updatedAt&quot;&gt;Updated &lt;Time ms={parseInt(meta.updated)} /&gt;&lt;/span&gt; }
        &lt;/span&gt;
}

</code></pre></div></div></div></section></section>
<section id="codeblock" depth="3" class="" startpos="61:1-519" endpos="65:4-576"><div startpos="61:1-519" endpos="61:14-532" class="cell"><div class="cell-content"><h3>Codeblock</h3></div></div><div startpos="63:1-534" endpos="65:4-576" class="code   cell"><div class="cell-content"><div class="dir-collapse lang-jsx local collapsed codecell"><span class="meta"><span class="lang">jsx</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; base/Codeblock.jsx</span></span><pre><code class="jsx">import React, { useState } from &#x27;react&#x27;
import {log, level} from &#x27;../../utils/console&#x27;
import { getConsoleForNamespace } from &#x27;../../utils/console&#x27;
import { DatesToRelativeDelta } from &#x27;../../utils/momento&#x27;
import Highlight from &#x27;react-highlight.js&#x27;
import SelectionContext from &#x27;../SelectionContext&#x27;
import {getViewer} from &#x27;../Viewers&#x27;
import {CodeMeta} from &#x27;../CodeMeta&#x27;

import { Identity } from &#x27;../../utils/functions&#x27;
import { ErrorBoundary } from &#x27;../ErrorBoundry&#x27;

const console = getConsoleForNamespace(&#x27;Codeblock&#x27;)

const hasDirective = (meta, d) =&gt; {
  return meta &amp;&amp; meta.directives &amp;&amp; meta.directives.length &amp;&amp; meta.directives.indexOf(d) &gt;= 0
}


export const Codeblock = props =&gt; {
        
  const codeNode = props.node.children
    &amp;&amp; props.node.children.length == 1
    &amp;&amp; props.node.children[0].tagName === &#x27;code&#x27;
    ? props.node.children[0] 
    : null;

  const meta = codeNode ? codeNode.properties.meta : null
  const dirs = (meta &amp;&amp; meta.directives) || []
  const tags = (meta &amp;&amp; meta.tags) || []
  const attrs = (meta &amp;&amp; meta.attrs) || {}
  const id = attrs.id || (meta &amp;&amp; meta.filename)
  const dirClasses = dirs.map(d=&gt;&#x27;dir-&#x27;+d)
  const tagClasses = tags.map(t=&gt;&#x27;tag-&#x27;+t)

  const hasDirective = (d) =&gt; {
    return meta &amp;&amp; meta.directives &amp;&amp; meta.directives.length &amp;&amp; meta.directives.indexOf(d) &gt;= 0
  }

  const [localRemote, setLocalRemote] = useState(&#x27;local&#x27;)
  const toggleLocalRemote = (ev) =&gt; {
    ev.stopPropagation()
    ev.preventDefault()
    setLocalRemote(localRemote === &#x27;local&#x27; ? &#x27;remote&#x27; : &#x27;local&#x27;)
    return false
  }
  const [fullScreen, setFullScreen] = useState(false)
  const toggleFullscreen = (ev) =&gt; {
    ev.stopPropagation()
    ev.preventDefault()
    setFullScreen(!fullScreen)
    return false
  }

  const [collapsed, setCollapsed] = useState(hasDirective(&#x27;collapse&#x27;) ? &#x27;collapsed&#x27; :  &#x27;&#x27;)
  const toggleCollapsed = (ev) =&gt; {
    ev.stopPropagation()
    ev.preventDefault()
    setCollapsed(collapsed === &#x27;collapsed&#x27; ? &#x27;uncollapsed&#x27; : &#x27;collapsed&#x27;)
    return false
  }
  
  const anchorClick = ev =&gt; {
     // add #id to history silently
     history.replaceState(undefined, undefined, `#${id || &#x27;&#x27;}`)
  }

  return &lt;SelectionContext.Consumer&gt;
    { ctx =&gt; {

      const Viewer = getViewer(meta, ctx.file.data &amp;&amp; ctx.file.data.plugins &amp;&amp;  ctx.file.data.plugins.viewer &amp;&amp; ctx.file.data.plugins.viewer)

      const classes = [
        ...dirClasses,
        ...tagClasses,
        meta &amp;&amp; `lang-${meta.lang}`,
        localRemote,
        collapsed,
        fullScreen &amp;&amp; &#x27;fullscreen&#x27;,
        &#x27;codecell&#x27;,
        meta &amp;&amp; meta.isOutput &amp;&amp; &#x27;output&#x27;,
      ].filter(Identity).join(&#x27; &#x27;)
      
      if (codeNode) {
        let source;
        if (codeNode.data &amp;&amp; codeNode.data.value) {
          source = codeNode.data.value;
        } else if (false &amp;&amp; codeNode.children &amp;&amp; codeNode.children[0]) {
          source = codeNode.children[0].value
        } else {
          console.log(&#x27;unknown source&#x27;)
          source = codeNode.value
        }
        codeNode.value = source

        const above = Viewer &amp;&amp; meta.directives &amp;&amp; (meta.directives.indexOf(&#x27;above&#x27;) &gt;= 0)
        const below = Viewer &amp;&amp; meta.directives &amp;&amp; (meta.directives.indexOf(&#x27;below&#x27;) &gt;= 0)
        const highlighted = &lt;Highlight language={(meta &amp;&amp; meta.lang) || &quot;plaintext&quot;}&gt;{source}&lt;/Highlight&gt;
        const metaView = meta &amp;&amp; &lt;CodeMeta meta={meta} toggleCollapsed={toggleCollapsed} toggleFullscreen={toggleFullscreen} toggleLocalRemote={toggleLocalRemote} /&gt;
        return &lt;div className={classes} onClick={anchorClick}&gt;
            { id &amp;&amp; &lt;a name={id}/&gt; }
            { meta &amp;&amp; !above &amp;&amp; metaView}
            { Viewer 
              ? &lt;ErrorBoundary&gt;
                  { below &amp;&amp; highlighted }
                  &lt;Viewer children={props.children} node={codeNode} React={React} fullscreen={fullScreen} file={ctx.file} lit={(typeof lit !== &#x27;undefined&#x27; ? lit : {})}/&gt;
                &lt;/ErrorBoundary&gt;
              : meta &amp;&amp; meta.isOutput
                ? &lt;output&gt;
                    {highlighted}
                  &lt;/output&gt;
                : (!above &amp;&amp; !below)
                   ? highlighted 
                   : null }
            { meta &amp;&amp; above &amp;&amp; metaView }
            { above &amp;&amp; highlighted }
        &lt;/div&gt;
      } else {
          console.log(&quot;Default codeblock&quot;, this.props.node.children[0])
          return &lt;div className=&quot;codecell&quot;&gt;&lt;pre className=&quot;default&quot;&gt;{props.children}&lt;/pre&gt;&lt;/div&gt;
      }
    }
  }&lt;/SelectionContext.Consumer&gt;
}

</code></pre></div></div></div></section>
<section id="link" depth="2" class="" startpos="67:1-578" endpos="71:4-624"><div startpos="67:1-578" endpos="67:8-585" class="cell"><div class="cell-content"><h2>Link</h2></div></div><div startpos="69:1-587" endpos="71:4-624" class="code   cell"><div class="cell-content"><div class="dir-collapse lang-jsx local collapsed codecell"><span class="meta"><span class="lang">jsx</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; base/Link.jsx</span></span><pre><code class="jsx">import React from &#x27;react&#x27;
import { ExternalLinkIcon, AnchorIcon } from &#x27;../Icons&#x27;
import { getConsoleForNamespace } from &#x27;../../utils/console&#x27;

const console = getConsoleForNamespace(&#x27;Link&#x27;)

const Link = props =&gt; {
    const title = props.node.properties.title
    const href = props.node.properties.href
    const data = props.data || {}
    const wikilink = props.wikilink ? &#x27;true&#x27; : undefined
    const icon = data.isExternal
                 ? &#x27;‚Üó&#x27;
                 : data.isFragment
                   ? &#x27;¬ß&#x27;
                   : null

    // console.log(&quot;&lt;Link/&gt;&quot;, data.exists)
    
    const local = !data.isFragment &amp;&amp; !data.isExternal
    const classNames = [
        props.className,
        data.exists &amp;&amp; &#x27;exists&#x27;,
        local &amp;&amp; &#x27;local&#x27;,
        data.isExternal &amp;&amp; &#x27;external&#x27;,
        data.isFragment &amp;&amp; &#x27;fragment&#x27;,
    ].filter(x=&gt;x).join(&#x27; &#x27;)

    const imgOnlyLink = props.node.children
                        &amp;&amp; props.node.children.length === 1
                        &amp;&amp; props.node.children[0].tagName === &#x27;img&#x27;

    return &lt;a className={classNames}
        {...props.node.properties}
        {...props.node.properties.data}
        wikilink={wikilink}&gt;
            {props.children}
            {icon &amp;&amp; !imgOnlyLink &amp;&amp; &lt;span className=&quot;linkIcon&quot;&gt;{icon}&lt;/span&gt; }
        &lt;/a&gt;
}

export default Link

</code></pre></div></div></div></section>
<section id="backlinks" depth="2" class="" startpos="73:1-626" endpos="77:4-677"><div startpos="73:1-626" endpos="73:13-638" class="cell"><div class="cell-content"><h2>Backlinks</h2></div></div><div startpos="75:1-640" endpos="77:4-677" class="code   cell"><div class="cell-content"><div class="dir-collapse lang-jsx local collapsed codecell"><span class="meta"><span class="lang">jsx</span><span style="color:black;background-color:#da5323" class="directive dir-collapse">collapse</span><span class="source">&lt; Backlinks.jsx</span></span><pre><code class="jsx">import React from &#x27;react&#x27;
import path from &#x27;path&#x27;

export default class Backlinks extends React.Component {
    render() {
        const links = this.props.links || []
        if (!links.length) return null

        const included = {}
        const deduped = links.filter( l =&gt; {
          if (!included[l.url]) {
             included[l.url] = true
             return true
          }
        })
        return &lt;&gt;
            &lt;h4&gt;{`Backlinks (${deduped.length})`}&lt;/h4&gt;
            &lt;ol&gt;
                {deduped.map( (link) =&gt; {
                    return  &lt;li key={link.url}&gt;&lt;a title={link.title} href={path.join(this.props.root, link.url)}&gt;{link.title}&lt;/a&gt;&lt;/li&gt;
                })}
            &lt;/ol&gt;
        &lt;/&gt;
    }
}

</code></pre></div></div></div></section></div></div><div id="backlinks"><h4>Backlinks (2)</h4><ol><li><a title="Client" href="/client/client.html">Client</a></li><li><a title="Renderer" href="/renderer/renderer.html">Renderer</a></li></ol></div><script src="//cdn.jsdelivr.net/npm/eruda"></script><script>eruda.init();</script><script async="" src="/web.bundle.js"></script></body></html>