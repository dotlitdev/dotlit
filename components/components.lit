

# React Components

## Table of Contents

## Document

```jsx < Document.jsx

```

## Header

```jsx < Header.jsx
import React, { useState } from 'react'
import * as clipboard from "clipboard-polyfill"

import SelectionContext from './SelectionContext'
import { Identity } from '../utils/functions'
import { getConsoleForNamespace } from '../utils/console'


const console = getConsoleForNamespace('Header')

const setDebug = ev => {
  ev.preventDefault()
  const key = 'litDebug'
  const example = '*,fs,client,Cell,sections,etc...'
  const storage = typeof localStorage !== 'undefined' && localStorage
  const val = prompt(key, storage.getItem(key) || example)
  storage.setItem( key, val )
  console.log(`Set ${key} to "${val}"`)
  return false
}

const showInspector = ev => {
  console.log('Show mobile inspector')
}

const Menu = props => {
  console.log('<Menu/>', props.title, props)

  const [open, setOpen] = useState(props.horizontal)
  const toggleOpen = _ => setOpen(!open)

  const classes = [
    props.horizontal ? 'horizontal' : null,
    open ? 'open' : null,
  ].filter(Identity).join(' ')

  const handleClickTitle = ev => {
    ev.stopPropagation()
    if (props.onClick) props.onClick()
    else if (props.href) location.href = props.href
    else toggleOpen()
    return false
  }

  const catchClicks = ev => {
    ev.stopPropagation()
    if (!props.horizontal) {
      toggleOpen()
    }
    return false
  }

  const disabled = !props.onClick && !props.href && !props.children

  return <menu className={classes} disabled={disabled} onClick={catchClicks}>
    <li className={"MenuTitle"} key="menu-title" onClick={handleClickTitle} >
      { props.href
        ? <a href={props.href}>{props.title}</a>
        : props.title}
      { open && props.horizontal && <span>|</span> }
    </li>
    { open && <li className="MenuItems">{ props.children }</li> }
  </menu>
}



export const Header = props => {
  console.log('<Header/>', props)

  const resetFile = ctx => async ev => {
    console.log("Reset File:", ctx.file)
    if (confirm(`Are you sure you want to delete the local copy of "${ctx.file}"`)) {
      await ctx.fs.unlink(lit.location.src)
      console.log("Deleted ", ctx.file, "reloading page")
      location.reload()
    }
  }

  const copyToClipboard = ctx => ev => {
    clipboard.writeText(ctx.src)
    console.log("Copied src to clipboard")
  }

  return <SelectionContext.Consumer>{(ctx) => {
    return <Menu title="Home" horizontal href={props.root}>
    <Menu title="File">
      <span disabled>New</span>
      <span disabled>Open</span>
      <span disabled>Save</span>
      <span onClick={copyToClipboard(ctx)}>Copy</span>
      <span onClick={resetFile(ctx)}>Reset</span>
      <span disabled>Delete</span>
    </Menu>
    <Menu title="Cell">
      <span disabled>Add</span>
      <span disabled>Remove</span>
      <span disabled>Edit</span>
      <span disabled>Execute</span>
      <span disabled>Reset</span>
      <Menu title="Move">
        <span>Up</span>
        <span>Down</span>
      </Menu>
      <Menu title="Copy">
        <span>Source</span>
        <span>Cell</span>
      </Menu>
    </Menu>
    <Menu title="Section">
      <span disabled>Collapse</span>
      <span disabled>Remove</span>
      <Menu title="Move">
        <span>Up</span>
        <span>Down</span>
      </Menu>
    </Menu>
    <Menu title="Help">
      <span onClick={setDebug}>Debug</span>
    </Menu>
  </Menu>
  }}
</SelectionContext.Consumer>
}
```
## App

```jsx < App.jsx
import React, {useState} from 'react'
import path from 'path'
import SelectionContext from './SelectionContext'
import patchSource from '../utils/unist-util-patch-source'
import { processor } from '../renderer'
import { getConsoleForNamespace } from '../utils/console'
import filter from 'unist-util-filter'
import {atPos} from '../utils/unist-util-select-position'
import {selectAll} from 'unist-util-select'

const console = getConsoleForNamespace('App')

const App = ({file, fs, result}) => {

    const [srcAndRes, setSrcAndRes] = useState({
        src: file.contents.toString(),
        res: result
    })
    const [res, setResult] = useState(result)
    const [selectedCell, setSelectedCell] = useState(null)
    
    const setSrcWrapper = async (pos, cellSource) => {
        console.log("<App/> Set src wrapper", pos, cellSource)
        const patchedSrc = patchSource(srcAndRes.src, pos, cellSource.trimEnd())
        
        file.contents = patchedSrc
        const processedFile = await processor(fs).process(file)
        console.log("Processed client", processedFile)
        setSrcAndRes({
            src: patchedSrc,
            res: processedFile.result
        })

        try {
            await fs.writeFile(file.path, patchedSrc, {encoding: 'utf8'})
        } catch (err) {
            console.log("Failed to write file source to fs", file.path, err)
        }
        
        const tmpEnd = {line: pos.start.line + cellSource.split('\n').length }
        const tmpPos = {start: pos.start, end: tmpEnd }
        const tree = filter(processedFile.data.ast, atPos(tmpPos))
        const nodes = selectAll('code', tree)
        console.log("[CodeCells in Change (pos)]", tmpPos, file.path, tree, nodes)
        for (const codeCell of nodes) {
            const filename = codeCell.data && codeCell.data.meta && codeCell.data.meta.filename
            if (filename) {
                const filepath = path.join( path.dirname(file.path), filename)
                await fs.writeFile(filepath, codeCell.value)
                console.log(`Wrote codefile ${filename} to "${filepath}" on disk`)
            }
       }
    }

    const state = {
      src: srcAndRes.src, 
      selectedCell, 
      setSelectedCell, 
      setSrc: setSrcWrapper
    }

    console.log('<App/> render', selectedCell)

    return <SelectionContext.Provider value={state}>
        <div id="content">{srcAndRes.res}</div>
    </SelectionContext.Provider>
}

export default App
```
## 


## Selection Context

```jsx < SelectionContext.jsx

```
## Cell

```jsx < Cell.jsx

```

### CellMenu

```jsx < CellMenu.jsx

```
## Editor

```jax < Editor.jsx

```

## Icons

```jsx < Icons.jsx

```

## Code

```jsx CodeMeta.jsx
import React from 'react'

export const CodeMeta = props => {
        return <span className="meta">
            <span className="lang">{props.meta.lang}</span>
            <span className="repl">{props.meta.repl}</span>
            <span className="filename">{props.meta.filename}</span>

            {props.meta.tags && <ul className="tags">{
                props.meta.tags.map( (tag, i) => <li key={tag+i}><span className="tag">{tag}</span></li>)
            }</ul>}

            {props.meta.directives && <ul className="directives">{
                
props.meta.directives.map( (dir, i) => <li key={dir+1}><span className="directive">{dir}</span></li>)
            }</ul>}
        </span>
}

```


```jsx base/Codeblock.jsx
import React from 'react'
import {log, level} from '../../utils/console'
import { getConsoleForNamespace } from '../../utils/console'
import Highlight from 'react-highlight.js'
import {CodeMeta} from '../CodeMeta'
const console = getConsoleForNamespace('codeblocks')


const viewers = {
  csv: val => {
    // return <pre>//CSV Viewer\n{val}</pre>

    const rows = val.split("\n").map( (row,i) => {
       const cols = row.split(",").map( (col,j) => <td key={j}>{col}</td>)
       return <tr key={i}>{cols}</tr>
    })

    return <table>{rows}</table>
  },
  html: val => <div dangerouslySetInnerHTML={{__html: val}}></div>,
  svg: val => <div dangerouslySetInnerHTML={{__html: val}}></div>,
  uri: val => <iframe src={val}></iframe>,
}

const getViewer = meta => {
  return meta && (meta.isOutput || (meta.directives && meta.directives.indexOf('inline') >= 0)) && viewers[meta.lang]
}

export default class Codeblock extends React.Component {
    render() {
        
        const codeNode = this.props.node.children
                            && this.props.node.children.length == 1
                            && this.props.node.children[0].tagName === 'code'
                            ? this.props.node.children[0] 
                            : null;
        const meta = codeNode ? codeNode.properties.meta : null
        const viewer = getViewer(meta)
       
        if (codeNode) {const source = codeNode.children[0].value
            console.log("[Codeblock]", meta)
            return <codecell>
                { meta && <CodeMeta meta={meta}/> }
                { viewer 
                  ? viewer(source)
                  : meta && meta.isOutput
                    ? <output><Highlight language={meta.lang}>{source}</Highlight></output>
                    : <Highlight language={meta.lang}>{source}</Highlight> }
            </codecell>
        } else {
            console.log("Default codeblock", this.props.node.children[0])
            return <codecell><pre>{this.props.children}</pre></codecell>
        }
    }
}
```

## Link

```jsx base/Link.jsx
import React from 'react'
import { getConsoleForNamespace } from '../../utils/console'

const console = getConsoleForNamespace('Link')

const Link = props => {
    const title = props.node.properties.title
    console.log("<Link/>", props)
    return <a className={props.className}
        href={props.href}
        title={title}
        wikilink={props.wikilink ? 'true' : undefined}>
            {props.children}
        </a>
}

export default Link
```

## Backlinks

```jsx Backlinks.jsx
import React from 'react'
import path from 'path'

export default class Backlinks extends React.Component {
    render() {
        return <>
            <h4>{`Backlinks (${this.props.links.length})`}</h4>
            <ol>
                {this.props.links.map( (link) => {
                    return  <li key={link.url}><a title={link.title} href={path.join(this.props.root, link.url)}>{link.title}</a></li>
                })}
            </ol>
        </>
    }
}
```










